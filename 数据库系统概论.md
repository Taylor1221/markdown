# 第一篇 基础篇

## 第1章	绪论

### 1.1 数据库系统概述

#### 1.1.1 数据库的4个基本概念

**1. 数据（data）**

- 描述事物的符号记录称为数据。
- 数据的含义称为数据的语义，数据与其予以是不可分的。

**2. 数据库（DataBase，DB）**
​		**数据库是长期储存在计算机内、有组织的、可共享的大量数据的集合**。数据库中的数据按一定的数据模型组织、描述和储存，具有**较小的冗余度(redundancy)**、**较高的数据独立性（data independency）**和**易扩展性(scalability)**，并**可为各种用户共享**。数据库数据具有三个基本特点：

- **永久存储**
- **有组织**
- **可共享**

**3. 数据库管理系统（DataBase Management System，DBMS）**
​		数据库管理系统是位于用户与操作系统之间的一层数据管理软件。数据库管理系统和操作系统一样是**计算机的基础软件**，也是一个大型复杂的软件系统。它的主要功能包括以下几个方面:
​		**(1) 数据定义功能**
        数据库管理系统提供数据定义语言（Data Definition Language，DDL)，用户通过它可以方便地对数据库中的数据对象的组成与结构进行定义。
​		**(2) 数据组织、存储和管理**
​		数据库管理系统要分类组织、存储和管理各种数据，包括数据字典、用户数据、数据的存取路径等。要确定以何种文件结构和存取方式在存储级上组织这些数据，如何实现数据之间的联系。数据组织和存储的基本目标是提高存储空间利用率和方便存取，提供多种存取方法（如索引查找、hash查找、顺序查找等）来提高存取效率。
​		**(3) 数据操纵功能**
        数据库管理系统还提供数据操纵语言(（Data Manipulation Language，DML)，用户可以使用它操纵数据，实现对数据库的基本操作，如查询、插入、删除和修改等。
​		**(4) 数据库的事务管理和运行管理**
        数据库在建立、运用和维护时由数据库管理系统统一管理和控制，以保证事务的正确运行，保证数据的安全性、完整性、多用户对数据的并发使用及发生故障后的系统恢复。
​		**(5) 数据库的建议和维护功能**
​		**(6) 其他功能**

**4. 数据库系统（DataBase System，DBS）**

​		数据库系统是由**数据库**、**数据库管理系统**（及其应用开发工具）、**应用程序**和**数据库管理员**（DataBase Administrator,DBA)组成的**存储**、**管理**、**处理**和**维护数据**的**系统**。

#### 1.1.2 数据库系统的特点

- **数据结构化**
- **数据的共享性高、冗余度低且易扩充**
- **数据独立性高**
- **数据由数据库管理系统统一管理和控制**

### 1.2 数据模型

​		==数据模型（data model）==也是一种模型，它是**对现实世界数据特征的抽象**。也就是说**数据模型是用来描述数据、组织数据和对数据进行操作的**。

​		***数据模型是数据库系统的核心和基础。***

#### 1.2.1 两类数据模型

​		根据模型**应用目的不同**，可以将这些模型划分为两大类，它们分别属于两个不同的层次。**第一类是概念模型，第二类是逻辑模型和物理模型**。
​		**第一类概念模型（conceptual model)**，也称**信息模型**，它是按用户的观点来对数据和信息建模，主要**用于数据库设计**。
​		**第二类中的逻辑模型**主要包括**层次模型(hierarchical model)**、**网状模型(network model**、**关系模型（relational model)**、**面向对象数据模型（object oriented data model)**和**对象关系数据模型（object relational data model)**、**半结构化数据模型(semistructured data model)**等。它是按计算机系统的观点对数据建模，主要**用于数据库管理系统的实现**。

#### 1.2.2 概念模型

![image-20220212135504775](https://gitee.com/enchantedqaq/cloudimage/raw/master/img/image-20220212135504775.png)

​		概念模型实际上是现实世界到机器世界的一个中间层次，用于信息世界的建模，是现实世界到信息世界的第一层抽象。

​		**1. 信息世界中的基本概念**

​		(1) **实体 (entity)**
​		**客观存在并可相互区别的事物称为实体**。实体可以是具体的人、事、物，也可以是抽象的概念或联系，例如，一个职工、一个学生、一个部门、一门课、学生的一次选课、部门的一次订货、教师与院系的工作关系（即某位教师在某院系工作）等都是实体。

​		(2) **属性 (attribute)**
​		**实体所具有的某一特性称为属性**。一个实体可以由若干个属性来刻画。例如，学生实体可以由学号、姓名、性别、出生年月、所在院系、入学时间等属性组成，属性组合(201315121，张山，男，199505，计算机系，2013）即表征了一个学生。

​		(3) **码 (key)**
​		**唯一标识实体的属性集称为码**。例如学号是学生实体的码。

​		(4) **实体型 (entity type)**
​		**具有相同属性的实体必然具有共同的特征和性质**。用实体名及其属性名集合来抽象和刻画同类实体，称为实体型。例如，学生(学号，姓名，性别，出生年月，所在院系，入学时间)就是一个实体型。

​		(5) **实体集 (entity set)**
​		**同一类型实体的集合称为实体集**。例如，全体学生就是一个实体集。

​		(6) **联系 (relationship)**
​		在现实世界中，事物内部以及事物之间是有联系的，这些联系在信息世界中反映为实体（型）内部的联系和实体（型）之间的联系。实体内部的联系通常是指组成实体的各属性之间的联系，**实体之间的联系通常是指不同实体集之间的联系**。
​		实体之间的联系有 **一对一**、**一对多**和多对多等多种类型。

​		**2. 概念模型的一种表示方法：实体-联系方法**

​		概念模型是对信息世界建模，所以概念模型应该能够方便、准确地表示出上述信息世界中的常用概念。概念模型的表示方法很多，其中最为常用的是P.P.S.Chen于1976年提出的**实体-联系方法（Entity-Relationship approach)**。该方法用E-R图(E-R diagram)来描述现实世界的概念模型，**E-R方法也称为E-R模型**。

#### 1.2.3 数据模型的组成要素

​		一般地讲，数据模型是严格定义的一组概念的集合。这些概念精确地描述了系统的静态特性、动态特性和完整性约束条件(integrity constraints)。因此**数据模型通常由数据结构、数据操作和数据的完整性约束条件三部分组成**。

​		**1. 数据结构**
​		数据结构描述数据库的组成对象以及对象之间的联系。也就是说，数据结构描述的内容有两类:一类是与对象的类型、内容、性质有关的，如网状模型中的数据项、记录，关系模型中的域、属性、关系等;一类是与数据之间联系有关的对象，如网状模型中的系型( set type)。
​		数据结构是所描述的对象类型的集合，是对系统静态特性的描述。

​		**2. 数据操作**
​		数据操作是指对数据库中各种对象（型）的实例（值）允许执行的操作的集合，包括操作及有关的操作规则。
​		数据库主要有查询和更新（包括插入、删除、修改）两大类操作。数据模型必须定义这些操作的确切含义、操作符号、操作规则（如优先级）以及实现操作的语言。
​		
​		**3. 数据的完整性约束条件**
​		数据的完整性约束条件是一组完整性规则。完整性规则是给定的数据模型中数据及其联系所具有的制约和依存规则，用以限定符合数据模型的数据库状态以及状态的变化，以保证数据的正确、有效和相容。

#### 1.2.4 常用的数据模型

- **层次模型（hierarchical model）**
- **网状模型（network model）**
- **关系模型（relationship model）**
- **面向对象数据模型（object oriented data model）**
- **对象关系数据模型（object relational data model）**
- **半结构化数据模型（semistructure data model）**

#### 1.2.5 层次模型

**1. 层次模型的数据结构（树形结构）**

​		在数据库中定义满足下面两个条件的基本层次联系的集合为层次模型：
​		(1) **有且只有一个结点没有双亲结点，这个结点称为根结点;**
​		(2) **根以外的其他结点有且只有一个双亲结点。**

​		在层次模型中，==每个结点表示一个记录类型，记录类型之间的联系用结点之间的连线(有向边)表示，这种联系是父子之间的一对多的联系==。这就使得**层次数据库系统只能处理一对多的实体联系**。

**2. 层次模型的数据操作与完整性约束**

​		层次模型的数据操纵主要有查询、插入、删除和更新。进行插入、删除、更新操作时要满足层次模型的完整性约束条件。

- 进行插入操作时,如果没有相应的双亲结点值就不能插入它的子女结点值。
- 进行删除操作时，如果删除双亲结点值，则相应的子女结点值也将被同时删除。

**3. 层次模型的优缺点**

​	层次模型的==优点==主要有:

- **层次模型的数据结构比较简单清晰**。
- **层次数据库的查询效率高（通常用指针实现）**。
- **层次数据模型提供了良好的完整性支持**。

​	层次模型的==缺点==主要有:

- 现实世界中很多联系是非层次性的，如结点之间具有**多对多联系，不适合用层次模型表示**。
- 如果一个结点具有多个双亲结点等，用层次模型表示这类联系就很笨拙，只能通过引入冗余数据（易产生不一致性）或创建非自然的数据结构（引入虚拟结点）来解决。**对插入和删除操作的限制比较多**，因此应用程序的编写比较复杂。
- **查询子女结点必须通过双亲结点**。
- 由于结构严密,**层次命令趋于程序化**。

***==层次模型更适合一对多的层次联系！！！==***

#### 1.2.6 网状模型

​		网状数据库系统采用网状模型作为数据的组织方式。**网状数据模型的典型代表是DBTG系统,亦称CODASYL 系统**。

**1. 网状模型的数据结构**

​		在数据库中，把满足以下两个条件的基本层次联系集合称为网状模型:
​		(1) **允许一个以上的结点无双亲**。
​		(2) **一个结点可以有多于一个的双亲**。

​		网状模型是一种比层次模型更具普遍性的结构。它去掉了层次模型的两个限制，**允许多个结点没有双亲结点**，**允许结点有多个双亲结点**;此外它还**允许两个结点之间有多种联系**（称之为复合联系)。因此，网状模型可以更直接地去描述现实世界。而层次模型实际上是网状模型的一个特例。

**2. 网状模型的数据操作与完整性约束**

​		(1) **支持记录码的概念，码即唯一标识记录的数据项的集合**。例如，学生记录(（如图1.13）中学号是码,因此数据库中不允许学生记录中学号出现重复值。
​		(2) **保证一个联系中双亲记录和子女记录之间是一对多的联系**。
​		(3) **可以支持双亲记录和子女记录之间的某些约束条件**。例如，有些子女记录要求双亲记录存在才能插入，双亲记录删除时也连同删除。例如图1.13中选课记录就应该满足这种约束条件,学生选课记录值必须是数据库中存在的某一学生选修存在的某一门课的记录。DBTG提供了“属籍类别”的概念来描述这类约束条件。

**3. 网状模型的优缺点**

​	网状模型的==优点==主要有:

- **能够更为直接地描述现实世界，如一个结点可以有多个双亲，结点之间可以有多种联系**。
- **具有良好的性能,存取效率较高**。

​	网状模型的==缺点==主要有:

- **结构比较复杂**，而且随着应用环境的扩大，数据库的结构就变得越来越复杂，不利于最终用户掌握。
- **网状模型的DDL、DML复杂**,并且要嵌入某一种高级语言(如 COBOL、C)中用户不容易掌握,不容易使用。
- 由于记录之间的联系是通过存取路径实现的，应用程序在访问数据时必须选择适当的存取路径，因此**用户必须了解系统结构的细节，加重了编写应用程序的负担**。

#### 1.2.7 关系模型（最重要）

**1. 关系模型的数据结构**

​		**从用户观点看，关系模型由一组关系组成。每个关系的数据结构是一张规范化的二维表**。以学生登记表为例：

|   学  号   | 姓  名 | 年  龄 | 性  别 | 系  名 | 年  级 |
| :--------: | :----: | :----: | :----: | :----: | :----: |
| 1710050103 | 陈致超 |   23   |   男   | 社会学 |  2017  |
| 1710050104 | 邓时凯 |   21   |   女   | 商品学 |  2017  |
| 1710050105 |  胡澳  |   22   |   男   |  工学  |  2017  |
|     ……     |   ……   |   ……   |   ……   |   ……   |   ……   |

- **关系 (relation)**：**一个关系对应通常说的一张表**，例如上图的这张学生登记表。

- **元组 (tuple)**：**表中的一行即为一个元组**。

- **属性 (attribute)**：**表中的一列即为一个属性，给每一个属性起一个名称即属性名**。如上图的表有6列，对应6个属性（学号，姓名，年龄，性别，系名和年级)。

- **码 (key)**：**也称为码键。表中的某个属性组，它可以唯一确定一个元组**，如上图的学号可以唯一确定一个学生，也就成为本关系的码。

- **域 (domain)**：**域是一组具有相同数据类型的值的集合**。属性的取值范围来自某个域。如人的年龄一般在 1—120岁之间，大学生年龄属性的域是(15~45岁),性别的域是(男，女)，系名的域是一个学校所有系名的集合。

- **分量**：**元组中的一个属性值**。

- **关系模式**：对关系的描述，一般表示为: **关系名 (属性1，属性2，…，属性n)**

​		例如，上面的关系可描述为: 学生 (学号，姓名，年龄，性别，系名，年级)

​		关系模型要求关系必须是规范化的，即要求关系必须满足一定的规范条件，这些规范条件中最基本的一条就是，关系的每一个分量必须是一个不可分的数据项，也就是说，不允许表中还有表。例如，下图中工资和扣除是可分的数据项，工资又分为基本工资、岗位津贴和业绩津贴，扣除又分为三险和个人所得税。因此，下图的表就不符合关系模型要求。

![image-20220212164227516](https://gitee.com/enchantedqaq/cloudimage/raw/master/img/image-20220212164227516.png)

可以把关系和现实生活中的表格所使用的术语做一个粗略的对比：

| 关系术语   | 一般表格的术语             |
| ---------- | -------------------------- |
| 关系名     | 表名                       |
| 关系模式   | 表头（表格的描述）         |
| 关系       | (一张）二维表              |
| 元组       | 记录或行                   |
| 属性       | 列                         |
| 属性名     | 列名                       |
| 属性值     | 列值                       |
| 分量       | 一条记录中的一个列值       |
| 非规范关系 | 表中有表（大表中嵌有小表） |

**2. 关系模型的数据操作与完整性约束**

​		关系模型的数据操纵主要包括==查询==、==插入==、==删除==和==更新数据==。这些操作必须满足关系的完整性约束条件。关系的完整性约束条件包括三大类: **实体完整性**、**参照完整性**和**用户自定义完整性**。

​		关系模型中的数据操作是集合操作，**操作对象和操作结果都是关系**，**即若干元组的集合**，而不像格式化模型中那样是单记录的操作方式。另一方面，**关系模型把存取路径向用户隐蔽起来，用户只要指出“干什么”或“找什么”，不必详细说明“怎么干”或“怎么找”**,从而大大地提高了数据的独立性,提高了用户生产率。

**3. 关系模型的优缺点**

​	关系模型的==优点==主要有:

- 关系模型与格式化模型不同,它是**建立在严格的数学概念的基础上**的。
- **关系模型的概念单一**。无论实体还是实体之间的联系都用关系来表示。对数据的检索和更新结果也是关系（即表)。所以其数据结构简单、清晰，用户易懂易用。
- 关系模型的存取路径对用户透明，从而**具有更高的数据独立性、更好的安全保密性**,也简化了程序员的工作和数据库开发建立的工作。

​	关系模型的==缺点==:

​		由于存取路径对用户是隐蔽的，**查询效率往往不如格式化数据模型**。为了提高性能，数据库管理系统必须对用户的查询请求进行优化，因此增加了开发数据库管理系统的难度。

### 1.3 数据库系统的结构

​		从数据库应用开发人员角度看，**数据库系统通常采用三级模式结构，这是数据库系统内部的系统结构**。从数据库最终用户角度看，数据库系统的结构分为单用户结构、主从式结构、分布式结构、客户-服务器、浏览器-应用服务器/数据库服务器多层结构等。这是数据库系统外部的体系结构。
​		本章介绍数据库系统的模式结构。

#### 1.3.1 数据库系统模式的概念

​		**在数据模型中有“型”(type) 和“值”(value) 的概念**。**型是指对某一类数据的结构和属性的说明，值是型的一个具体赋值**。例如，学生记录定义为(学号，姓名，性别，系别，年龄，籍贯）这样的记录型，而（201315130，李明，男，计算机系，19，江苏南京市)则是该记录型的一个记录值。
​		**模式(schema) 是数据库中全体数据的逻辑结构和特征的描述，它仅仅涉及型的描述，不涉及具体的值**。模式的一个具体值称为模式的一个实例(instance)。同一个模式可以有很多实例。
​		**模式是相对稳定的，而实例是相对变动的**，因为数据库中的数据是在不断更新的。模式反映的是数据的结构及其联系，而实例反映的是数据库某一时刻的状态。
​		数据库管理系统在**体系结构上**通常都具有相同的特征，即**采用三级模式结构**（早期微机上的小型数据库系统除外）并**提供两级映像功能**。

#### 1.3.2 数据库系统的三级模式结构

​		数据库系统的三级模式结构是指数据库系统是由==外模式==、==模式==和==内模式==三级构成。如下图所示：

![image-20220212170255353](https://gitee.com/enchantedqaq/cloudimage/raw/master/img/image-20220212170255353.png)

​		**1. 模式（schema）**
​		**模式也称逻辑模式，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图**。它是数据库系统模式结构的中间层，既不涉及数据的物理存储细节和硬件环境，又与具体的应用程序、所使用的应用开发工具及高级程序设计语言无关。
​		模式实际上是数据库数据在逻辑级上的视图。一个数据库只有一个模式。数据库模式以某一种数据模型为基础，统一综合地考虑了所有用户的需求，并将这些需求有机地结合成一个逻辑整体。定义模式时不仅要定义数据的逻辑结构，例如数据记录由哪些数据项构成，数据项的名字、类型、取值范围等;而且要定义数据之间的联系，定义与数据有关的安全性、完整性要求。
​		数据库管理系统提供模式数据定义语言(模式 DDL）来严格地定义模式。











## 第2章	关系数据库

### 2.1 关系数据结构及形式化定义

​		按照数据模型的三个要素，**关系模型由关系数据结构**、**关系操作集合**和**关系完整性约束**三部分组成。下面将对这三部分内容进行分别介绍。其中2.1节讲解关系数据结构，包括关系的形式化定义及有关概念;2.2节讲解关系操作;2.3节讲解关系的三类完整性约束;2.4节讲解关系代数，这是关系数据库系统中实现关系操作的一种语言;最后，在2.5节介绍关系演算。

#### 2.1.1 关系

​		关系模型的数据结构非常简单，只包含单一的数据结构——关系。在用户看来，关系模型中数据的逻辑结构是一张扁平的二维表。

​		1.**域（domain）**
​		**定义 2.1**	==域是一组具有相同数据结构类型的值的集合==。
​		例如，自然数、整数、实数、长度小于25字节的字符串集合、{0，1}、{男，女}、大于等于0且小于等于100的正整数等,都可以是域。

​		2.**笛卡尔积（cartesian product）**
​		笛卡尔积是域上的一种集合运算。
​		**定义 2.2**	给定一组域 D~1~，D~2~，…，D~n~，允许其中某些域是相同的，D~1~，D~2~，…，D~n~的笛卡尔积为：
​		==D~1~×D~2~×…×D~n~ = { (d~1~，d~2~，…，d~n~) | d~i~∈D~i~，i=1, 2, …, n }==
​		其中，每一个元素(d~1~，d~2~，…，d~n~)叫作一个**n元组(n-tuple)**，或简称**元组（tuple)**。元素中的每一个值D~i~叫做一个**分量（component)**。
​		一个域允许的不同取值个数称为这个域的基数（cardinal number)。

![image-20220215161235607](https://gitee.com/enchantedqaq/cloudimage/raw/master/img/image-20220215161235607.png)

​		3.**关系（relation）**
​		**定义 2.3**	D~1~×D~2~×…×D~n~ 的子集叫做在域 D~1~，D~2~，…，D~n~ 上的关系，表示为：
$$
R(\ce{D1,D2,…,Dn})
$$
​		这里 R 表示关系的名字，n 是关系的 **目** 或 **度**  (degree)。
​		关系中的每个元素是关系中的元组，通常用 t 表示。
​		当 n=1 时，称该关系为 **单元** 关系 (unary relation)，或一元关系。
​		当 n=2 时，称该关系为 **二元** 关系 (binary relation)。
​		关系是笛卡儿积的有限子集，所以关系也是一张二维表，表的每行对应一个元组，表的每列对应一个域。由于域可以相同，为了加以区分，必须对每列起一个名字,称为属性 (attribute)。n目关系必有 n 个属性。

​		若关系中的 **某一属性组（1个或多个属性）的值能唯一地标识一个元组，而其子集不能**（若从该属性组中 **去掉任何一个属性**，该属性组就**不能唯一标识一个元组**），则称该属性组为候选码（candidate key).
​		***一个关系中，可能有很多组候选码***
​		当有多个候选码时，可以选定一个作为 **主码** (primary key)。
​		**DBMS** 以 **主码** 为主要线索管理关系中的各个元组。
​		包含在 **任何一个 候选码 中的属性** 被称作 **主属性** (prime attribute)，而其他属性被称作 **非主属性** (non-prime attribute) 或 **非码属性 ** (non-key attribute)。
​		最简单的，候选码只包含一个属性。
​		最极端的，所有属性构成这个关系的候选码，称为 **全码 (All-Key)**。

​		**关系可以有三种类型:基本关系（通常又称为基本表或基表)、查询表和视图表**。其中，基本表是实际存在的表，它是实际存储数据的逻辑表示；查询表是查询结果对应的表；视图表是由基本表或其他视图表导出的表,是虚表，不对应实际存储的数据。

#### 2.1.2 关系模式

​		在数据库中要区分型和值。关系数据库中，关系模式是型，关系是值。关系模式是对关系的描述,关系是元组的集合，因此关系模式必须指出这个元组集合的结构，即它由哪些属性构成，这些属性来自哪些域，以及属性与域之间的映像关系。

​		**定义 2.4**	关系的描述称为关系模式（relation schema)。它可以形式化地表示为：
$$
R(U,D,DOM,F)
$$
​		其中R为关系名，U为组成该关系的属性名集合，D为U中属性所来自的域，DOM为属性向域的映像集合，F为属性间数据的依赖关系集合。

#### 2.1.3 关系数据库

​		在关系模型中，实体以及实体间的联系都是用关系来表示的。例如导师实体、研究生实体、导师与研究生之间的一对多联系都可以分别用一个关系来表示。在一个给定的应用领域中，**所有关系的集合构成一个关系数据库**。
​		关系数据库也有型和值之分。**关系数据库的型也称为关系数据库模式，是对关系数据库的描述**。关系数据库模式包括若干域的定义，以及在这些域上定义的若干关系模式。
​		**关系数据库的值是这些关系模式在某一时刻对应的关系的集合，通常就称为关系数据库**。

#### 2.1.4 关系模型的存储结构

​		我们已经知道，**在关系数据模型中实体及实体间的联系都用表来表示，但表是关系数据的逻辑模型**。在关系数据库的物理组织中，有的关系数据库管理系统中一个表对应一个操作系统文件，将物理数据组织交给操作系统完成；有的关系数据库管理系统从操作系统那里申请若干个大的文件，自己划分文件空间，组织表、索引等存储结构，并进行存储管理。

### 2.2 关系操作

#### 2.2.1 基本的关系操作

​		关系模型中常用的关系操作包括查询（query）操作和插入（insert）、删除（delete）、修改（update）操作两大部分。
​		关系的查询表达能力很强，是关系操作中最主要的部分。查询操作又可以分为**选择（select）**、**投影（project）**、**连接（join）**、**除（divide）**、**并（union）**、**差（except）**、**交（intersection）**、**笛卡儿积 **等。其中**选择、投影、并、差、笛卡儿积是5种基本操作**，其他操作可以用基本操作来定义和导出，就像乘法可以用加法来定义和导出一样。
​		关系操作的特点是集合操作方式，即 **操作的对象和结果都是集合**。这种操作方式也称为一次一集合(set-at-a-time）的方式。相应地，非关系数据模型的数据操作方式则为一次一记录（record-at-a-time）的方式。

#### 2.2.2 关系数据语言的分类

![image-20220215191724792](https://gitee.com/enchantedqaq/cloudimage/raw/master/img/image-20220215191724792.png)

### 2.3 关系完整性

​		关系模型的完整性规则是对关系的某种约束条件。也就是说关系的值随着时间变化时应该满足一些约束条件。这些约束条件实际上是现实世界的要求。任何关系在任何时刻都要满足这些语义约束。
​		**关系模型中有三类完整性约束：实体完整性 (entity integrity)、参照完整性 (referentialintegrity) 和 用户定义的完整性 (user-defined integrity)**。其中**实体完整性和参照完整性是关系模型必须满足的完整性约束条件，被称作是关系的两个不变性**，应该由关系系统自动支持。用户定义的完整性是应用领域需要遵循的约束条件，体现了具体领域中的语义约束。

#### 2.3.1 实体完整性（对于主码而言）

​		**规则 2.1	实体完整性规则**	若属性（指一个或一组属性）A是基本关系R的主属性，则A不能取空值(null value)。所谓空值就是“不知道”或“不存在”或“无意义”的值。
​		对于实体完整性规则说明如下:
​		(1) 实体完整性规则是针对基本关系而言的。一个基本表通常对应现实世界的一个实体集。例如学生关系对应于学生的集合。
​		(2) 现实世界中的实体是可区分的，即它们具有某种唯一性标识。例如每个学生都是独立的个体，是不一样的。
​		(3) 相应地，关系模型中以主码作为唯一性标识。孙出啦祝掉法医
​		(4) 主码中的属性即主属性不能取空值。如果主属性取空值，就说明存在某个不可标识的实体，即存在不可区分的实体，这与第 (2) 点相矛盾，因此这个规则称为实体完整性。

#### 2.3.2 参照完整性（对于外码而言）

​		**定义 2.5**	设 F 是基本关系 R 的一个或一组属性，但不是关系 R 的码，K~s~ 是基本关系 S 的主码。如果 F 与 K~s~ 相对应，则称 F 是 R 的 **外码 (foreign key)**，并称基本关系 R 为参照关系 (referencing relation)，基本关系 S 为被参照关系 (referenced relation) 或目标关系 (target relation)。关系 R 和 S 不一定是不同的关系。

![image-20220215192703473](https://gitee.com/enchantedqaq/cloudimage/raw/master/img/image-20220215192703473.png)

​		显然，目标关系 S 的主码 K~s~ 和参照关系 R 的外码 F 必须定义在同一个（或同一组）域上。

​		***两个关系通常是靠外码连接起来的***

​		**规则 2.2**	**参照完整性规则**	若属性 (或属性组) F 是基本关系 R 的外码，它与基本关系 S 的主码 K，相对应（基本关系 R 和 S 不一定是不同的关系），则对于 R 中每个元组在 F 上的值必须:

- 要么取空值 ( F 的每个属性值均为空值 )；
- 要么等于 S 中某个元组的主码值。

#### 2.3.3 用户自定义完整性

​		用户针对具体的应用环境定义的完整性约束条件。
​		例如：uid要求是10位数字的正整数、username不能为空等。

### 2.4 关系代数

​		关系代数是一种抽象的查询语言，它**用对关系的运算来表达查询**。

​		关系代数的运算按运算符的不同可分为 **传统的集合运算** 和 **专门的关系运算** 两类。其中,传统的集合运算将关系看成元组的集合,其运算是从关系的“水平”方向，即行的角度来进行;而专门的关系运算不仅涉及行，而且涉及列。比较运算符和逻辑运算符是用来辅助专门的关系运算符进行操作的。

![image-20220215193622630](https://gitee.com/enchantedqaq/cloudimage/raw/master/img/image-20220215193622630.png)

#### 2.4.1 传统的集合运算

​		传统的集合运算是二目运算，包括 **并**、**差**、**交**、**笛卡儿积** 4种运算。

| **UNION（并）**                   | **R** | **S** | **R∪S** |
| :-------------------------------- | :---: | :---: | :-----: |
| **INTERSECTION（交）**            | **R** | **S** | **R∩S** |
| **DIFFERENCE（差）**              | **R** | **S** | **R-S** |
| **Cartesian PRODUCT（笛卡尔积）** | **R** | **S** | **R×S** |

​		传统集合运算举例：

![image-20220215194036206](https://gitee.com/enchantedqaq/cloudimage/raw/master/img/image-20220215194036206.png)

#### 2.4.2 专门的关系运算

​		专门的关系运算包括 **选择**、**投影**、**连接**、**除** 运算等。

| PROJECT（投影）    |   R   |       |    π~A~(R)    |
| :----------------- | :---: | :---: | :-----------: |
| **SELECT（选择）** | **R** |       | **σ~Con~(R)** |
| **JOIN（连接）**   | **R** | **S** | **R⋈~AθB~S**  |
| **DIVISION（除）** | **R** | **S** |    **R÷S**    |

​		设有一个学生—课程数据库，包括学生关系 Student 、课程关系 Course 和选修关系 SC 如下图所示。下面的多个例子将对这三个关系进行运算。

![image-20220215194650875](https://gitee.com/enchantedqaq/cloudimage/raw/master/img/image-20220215194650875.png)

![image-20220215194810569](https://gitee.com/enchantedqaq/cloudimage/raw/master/img/image-20220215194810569.png)

​		**1.选择（selection）**
​		选择又称为限制（restriction)。它是在关系 R 中选择满足给定条件的诸元组，记作：
​				***σ~F~(R)={t|t∈R∧F(t)='真'}***
​		其中 F 表示选择条件，它是一个逻辑表达式，取逻辑值 “真” 或 “假”。
​		逻辑表达式F的基本形式为：
​				***X~1~θY~1~***
​		其中 θ 表示比较运算符，它可以是>，≥，<，≤，=或<>（不等号）。X~1~，Y~1~等是属性名，或为常量，或为简单函数;属性名也可以用它的序号来代替。在基本的选择条件上可以进一步进行逻辑运算，即进行求非(┐)、与（⋀）、或（⋁）运算。
​		选择运算实际上是从关系 R 中选取使逻辑表达式 F 为真的元组。这是 **从行的角度进行的运算**。

​		**[例2.1]**	查询信息系（IS 系）全体学生。

​				**σ~Sdept='IS'~(Student)**

​		结果如下表所示：

|    Sno    | Sname | Ssex | Sage | Sdept |
| :-------: | :---: | :--: | :--: | :---: |
| 201215125 | 张立  |  男  |  19  |  IS   |

​		**2.投影（projection）**
​		关系R上的投影是从R中选择出若干属性列组成新的关系。记作：
​				***π~A~(R) = {t[A] | t∈R}***
其中A为R中的属性列。
​		投影操作是 **从列的角度进行的运算**。

​		**[例2.2]**	查询学生的姓名和所在系，即求Student关系上学生姓名和所在系两个属性上的投影。

​				**π~Sname，Sdept~(Student)**

​		结果如下表所示：

| Sname | Sdept |
| :---: | :---: |
| 李勇  |  CS   |
| 刘晨  |  CS   |
| 王敏  |  MA   |
| 张立  |  IS   |

​		**[例2.3]**	查询学生关系Student中都有哪些系，即查询关系 Student 上所在系属性上的投影。

​				**π~Sdept~(Student)**

​		结果如下图所示：

![image-20220216174800855](https://gitee.com/enchantedqaq/cloudimage/raw/master/img/image-20220216174800855.png)

​		投影之后**不仅取消了原关系中的某些列，而且还可能取消某些元组**，因为取消了某些属性列后，就可能出现重复行，应取消这些完全相同的行。

​		**3.连接（join）**
​		连接也称为 θ 连接。它是从两个关系的笛卡儿积中选取属性间满足一定条件的元组。记作：

![image-20220218131012392](https://gitee.com/enchantedqaq/cloudimage/raw/master/img/image-20220218131012392.png)

​		其中，A 和 B 分别为R 和 S 上列数相等且可比的属性组，θ 是比较运算符。连接运算从 R 和 S的笛卡儿积 R×S 中选取 R 关系在 A 属性组上的值与 S 关系在 B 属性组上的值满足比较关系 θ 的元组。
​		连接运算中有两种最为重要也最为常用的连接，**一种是等值连接（equijoin)**，**另一种是自然连接(natural join)**。
​		**θ 为 “=” 的连接运算称为等值连接**。它是从关系R与S的广义笛卡儿积中选取A、B属性值相等的那些元组,即等值连接为：

![image-20220218131322833](https://gitee.com/enchantedqaq/cloudimage/raw/master/img/image-20220218131322833.png)

​		**自然连接是一种特殊的等值连接**。它要求两个关系中进行比较的分量必须是同名的属性组,并且在结果中把重复的属性列去掉。即若R和S中具有相同的属性组B,U为R和S的全体属性集合，则自然连接可记作：

![image-20220218131348375](https://gitee.com/enchantedqaq/cloudimage/raw/master/img/image-20220218131348375.png)

![image-20220218132057395](https://gitee.com/enchantedqaq/cloudimage/raw/master/img/image-20220218132057395.png)

​		两个关系 R 和 S 在做自然连接时，选择两个关系在公共属性上值相等的元组构成新的关系。此时，关系 R中某些元组有可能在 S 中不存在公共属性上值相等的元组，从而造成 R 中这些元组在操作时被舍弃了，同样, S 中某些元组也可能被舍弃。**这些被舍弃的元组称为悬浮元组 (dangling tuple)**。例如，在图2.7(e)的自然连接中，R 中的第4个元组，S 中的第5个元组都是被舍弃掉的悬浮元组。
​		如果**把悬浮元组也保存在结果关系中，而在其他属性上填空值(NULL),那么这种连接就叫做外连接 (outer join)，记作 R⋈S**；如果**只保留左边关系 R 中的悬浮元组就叫做左外连接 (left outer join或left join)，记作R⋊S**；如果**只保留右边关系 S 中的悬浮元组就叫做右外连接（right outer join或right join)，记作R⋉S**。图(a)是图2.7中的关系 R 和关系 S 的外连接，图(b)是左外连接，图(c)是右外连接。

![image-20220218132814322](https://gitee.com/enchantedqaq/cloudimage/raw/master/img/image-20220218132814322.png)

​		**4.除运算（division）**
​		设关系R 除以关系S 的结果为关系 T，则 **T 包含所有在 R 但不在 S 中的属性及其值，且 T 的元组与 S 的元组的所有组合都在 R 中**。
​		下面用象集来定义除法:
​		给定关系 R(X，Y) 和 S(Y，Z)，其中 X、Y、Z 为属性组。R 中的 Y 与 S 中的 Y 可以有不同的属性名,但必须出自相同的域集。
​		R 与 S 的除运算得到一个新的关系 P(X)，P 是 R 中满足下列条件的元组在 X 属性列上的投影：元组在 X 上分量值 x 的象集 Y~x~ 包含 S 在 Y 上投影的集合。记作：
​				***R÷S = {t~r~ [X] | t~r~∈ R⋀ ∏~Y~(S)⊆Y~x~ }***
其中 Y 为 x 在 R 中的象集,x=t~r~ [X]。
​		除操作是 **同时从行和列角度进行运算**。
​		**[例2.4]**	设关系 R、S 分别如下图，则 R÷S 的结果为：

![image-20220218134315557](https://gitee.com/enchantedqaq/cloudimage/raw/master/img/image-20220218134315557.png)

​		在关系 R 中，A 可以取4个值{a~1~，a~2~，a~3~，a~4~}。其中：
​				a~1~的象集为{(b~1~，c~2~)，(b~2~，c~3~)，(b~2~，c~1~)}
​				a~2~的象集为{(b~3~，c~7~)，(b~2~，c~3~)}
​				a~3~的象集为{(b~4~，c~6~)}
​				a~4~的象集为{(b~6~，c~6~)}
S 在(B，C)上的投影为{(b~1~，c~2~)，(b~2~，c~1~)，(b~2~，c~3~)}。
​	显然只有显然**只有a~1~的象集(B，C)~a1~包含了 S 在(B，C)属性组上的投影**，所以
​			**R÷S = {a~1~}**

## 第 3 章	关系数据库标准语言 SQL

​		结构化查询语言（Structured Query Language，SQL）是关系数据库的标准语言，也是一个通用的、功能极强的关系数据库语言。其功能不仅仅是查询，而是包括数据库模式创建、数据库数据的插入与修改、数据库安全性完整性定义与控制等一系列功能。

### 3.1 学生—课程数据库

​		本章以学生—课程数据库为例来讲解 SQL 的数据定义、数据操纵、数据查询和数据控制语句。
​		为此，首先要定义一个学生—课程模式 S-T。学生—课程数据库中包括以下三个表，它们的定义如下：

- 学生表：Student(Sno,Sname,Ssex,Sage,Sdept)
- 课程表：Course(Cno,Cname,Cpno,Ccredit)
- 学生选课表：SC(Sno,Cno,Grade)

**Student表：**

|  学号 Sno  | 姓名 Sname | 性别 Ssex | 年龄 Sage | 所在系 Sdept |
| :--------: | :--------: | :-------: | :-------: | :----------: |
| 1710050103 |   陈致超   |    男     |    24     |      CS      |
| 1710050104 |   邓时凯   |    女     |    25     |      CS      |
| 1710050105 |    胡澳    |    男     |    23     |      MA      |
| 1710050106 |   华云龙   |    女     |    23     |      IS      |

**Course表：**

| 课程号 Cno | 课程名 Cname | 先行课 Cpno | 学分 Ccredit |
| :--------: | :----------: | :---------: | :----------: |
|     1      |    数据库    |      5      |      4       |
|     2      |     数学     |             |      2       |
|     3      |   信息系统   |      1      |      4       |
|     4      |   操作系统   |      6      |      3       |
|     5      |   数据结构   |      7      |      4       |
|     6      |   数据处理   |             |      2       |
|     7      |  PASCAL语言  |      6      |      4       |

**SC表（学生—课程关联表）：**

|  学号 Sno  | 课程号 Cno | 成绩 Grade |
| :--------: | :--------: | :--------: |
| 1710050103 |     1      |     91     |
| 1710050104 |     1      |     92     |
| 1710050104 |     2      |     85     |
| 1710050104 |     3      |     88     |
| 1710050105 |     2      |     90     |
| 1710050105 |     3      |     80     |
| 1710050106 |     5      |     86     |

### 3.2 数据定义

​		关系数据库系统支持三级模式结构，其模式、外模式和内模式中的基本对象有模式、表、视图和索引等。因此SOL 的数据定义功能包括模式定义、表定义、视图和索引的定义。

![image-20220220193411454](https://gitee.com/enchantedqaq/cloudimage/raw/master/img/image-20220220193411454.png)

#### 3.2.1 模式的定义与删除

​		**1.定义模式**
​		在SOL 中，模式定义语句如下:

​				***CREATE SCHEMA <模式名> AUTHORIZATION <用户名>;***

如果没有指定<模式名>，那么<模式名>隐含为<用户名>。
​		要创建模式，调用该命令的用户必须拥有数据库管理员权限，或者获得了数据库管理员授予的 CREATE SCHEMA 的权限。
​		**[例 3.1]**	为用户 WANG 定义一个学生—课程模式 S-T。

​				**CREATE SCHEMA "S-T" AUTHORIZATION WANG**;

​		**[例 3.2]**	**CREATE SCHEMA AUTHORIZATION WANG**；

​		该语句没有指定<模式名>，所以<模式名>隐含为用户名 WANG。

​		目前，在 CREATE SCHEMA 中可以接受 CREATE TABLE, CREATE VIEW和 GRANT子句。也就是说用户可以在创建模式的同时在这个模式定义中进一步创建基本表、视图，定义授权。即

​				***CREATE SCHEMA <模式名> AUTHORIZATION <用户名> [<表定义字句> |<视图定义子句>| <授权定义子句>] ;***

​		**<a name="3.3">[例 3.3]</a>**	为用户 ZHANG 创建一个模式 TEST，并且在其中定义一个表 TAB1。

​				**CREATE SCHEMA TEST AUTHORIZATION ZHANG**
**​				CREATE TABLE TAB1(COL1 SMALLINT,**
**​													 COL2 INT,**
**​													 COL3 CHAR(20),**
**​													 COL4 NUMERIC(10,3),**
**​													 COL5 DECIMAL(5,2)**
**​													 );**

​		**2.删除模式**
​		在 SQL 中，删除模式语句如下：
​		***DROP SCHEMA <模式名><CASCADE |RESTRICT***;
其中 CASCADE 和 RESTRICT 两者必选其一。选择了 CASCADE（级联），表示在删除模式的同时把该模式中所有的数据库对象全部删除;选择了 RESTRICT（限制），表示如果该模式中已经定义了下属的数据库对象（如表、视图等)，则拒绝该删除语句的执行。只有当该模式中没有任何下属的对象时才能执行 DROP SCHEMA 语句。

​		**[例 3.4]**	**DROP SCHEMA ZHANG CASCADE**;

​		该语句删除了模式 ZHANG，同时，该模式中已经定义的表 TAB1 也被删除了。

#### 3.2.2 基本表的定义、删除和修改

​		**1.定义基本表**
​		创建了一个模式就建立了一个数据库的命名空间，一个框架。在这个空间中首先要定义的是该模式包含的数据库基本表。
​		SQL 语言使用 **CREATE TABLE** 语句定义基本表，其基本格式如下：

**​				CREATE TABLE <表名> (<列名><数据类型> [列级完整性约束条件],**
**​														  <列名><数据类型> [列级完整性约束条件],**
**​														  …**
**​														  <列名><数据类型> [列级完整性约束条件],**
**​														  <表级完整性约束条件>);**

​		建表的同时通常还可以定义与该表有关的完整性约束条件，这些完整性约束条件被存入系统的数据字典中，当用户操作表中数据时由关系数据库管理系统自动检查该操作是否违背这些完整性约束条件。如果完整性约束条件涉及该表的多个属性列，则必须定义在表级上，否则既可以定义在列级也可以定义在表级。

​		**[例 3.5]**	建立一个 “学生” 表 Student。

​				**CREATE TABLE Student**
**​					(Sno CHAR(9) PRIMARY KEY,**
**​					Sname CHAR(20) UNIQUE,**
**​					Ssex CHAR(2),**
**​					Sage SMALLINT,**
**​					Sdept CHAR(20)**
**​					);**

​		系统执行该 CREATE TABLE 语句后,就在数据库中建立一个新的空 “学生” 表 Student，并将有关 “学生” 表的定义及有关约束条件存放在数据字典中。

​		**[例 3.6]**	建立一个 “课程” 表 Course。

​				**CREATE TABLE Course**
**​					(Cno CHAR(4) PRIMARY KEY,	/* 列级完整性约束条件，Cno 是主码 * /**
**​					Cname CHAR(40) NOT NULL,	 /* 列级完整性约束条件，Cname 不能取空值 * /**
**​					Cpno CHAR(4),	/* Cpno 的含义是先修课 * /**
**​					Cceredit SMALLINT,**
**​					FOREIGN KEY (Cpno) REFERENCES Course(Cno)	/* 表级完整性约束条件，Cpno 是外码，被参考表是 Course，被参照列是 Cno */**
**​					);**

​		本例说明 **参照表和被参照表可以是同一个表**。

​		**[例 3.7]**	建立一个 “学生选课” 表 SC。

​				**CREATE TABLE SC**
**​					(Sno CHAR(9),**
**​					Cno CHAR(4),**
**​					Grade SMALLINT,**
**​					PRIMARY KEY (Sno,Cno),**
**​					FOREIGN KEY (Sno) REFERENCES Student(Sno),**
**​					FOREIGN KEY (Cno) REFERENCES Course(Cno)**
**​					);**

​		**2.数据类型**
​		关系模型中一个很重要的概念是域。每一个属性来自一个域，它的取值必须是域中的值。
​		在 SQL中域的概念用数据类型来实现。定义表的各个属性时需要指明其数据类型及长度。SQL 标准支持多种数据类型，下面列出了几种常用数据类型。要注意，不同的关系数据库管理系统中支持的数据类型不完全相同。

|   数据类型   |                             含义                             |
| :----------: | :----------------------------------------------------------: |
|   char(n)    | 长度为 n 的定长字符串，若插入的长度小于定义长度，则用空格进行填充 |
|  varchar(n)  |                  最大长度为 n 的变长字符串                   |
|   smallint   | 短整数（2字节，一字节由8个二进制位组成）。如果有符号，允许范围为-32768至32767。如果无符号，允许的范围是从0到65535 |
| int，integer | 长整数（4字节）。如果是有符号的，它允许的范围是从-2147483648到2147483647。如果是无符号，允许的范围是从0到4294967295 |
|    bigint    | 大整数（8字节）。如果有符号，允许范围为-9223372036854775808到9223372036854775807。如果无符号，允许的范围是从0到18446744073709551615 |
| numeric(p,d) | 定点数，由 p 位数字（不包括符号、小数点）组成，小数点后面有 d 位数字 |
|   float(n)   |            可选精度的浮点数，精度至少为 n 位数字             |
|     date     |           日期，包含年、月、日，格式为 YYYY-MM-DD            |
|     time     |         时间，包含一日的时、分、秒，格式为 HH:MM:SS          |
|  timestamp   |                          时间戳类型                          |

​		**3.模式与表**
​		每一个基本表都属于某一个模式，一个模式包含多个基本表。当定义基本表时一般可以有三种方法定义它所属的模式。
​		方法一：在表名中明显地给出模式名。
​				CREATE TABLE "S-T".Student(…);		/* Student 所属的模式是 S-T */
​				CREATE TABLE "S-T".Course(…);		 / * Course 所属的模式是 S-T */
​				CREATE TABLE "S-T".SC(…);				 / * SC 所属的模式是 S-T */
​		方法二：在创建模式语句中同时创建表，如<a href="#3.3"> 例3.3 </a>所示。
​		方法三：设置所属的模式，这样在创建表时表名中不必给出模式名。
​		当用户创建基本表（其他数据库对象也一样）时若没有指定模式，系统根据搜索路径(search path）来确定该对象所属的模式。

​		**4.修改基本表**
​		随着应用环境和应用需求的变化，有时需要修改已建立好的基本表。SQL 语言用ALTER TABLE语句修改基本表,其一般格式为

​		**ALTER TABLE <表名>**
**​		[ ADD [COLUMN] <新列名><数据类型> [完整性约束] ]**
**​		[ ADD <表级完整性约束> ]**
**​		[ DROP [COLUMN] <列名> [CASCADE | RESTRICT ] ]**
**​		[ DROP CONSTRAINT<完整性约束名> [RESTRICT | CASCADE ] ]**
**​		[ ALTER COLUMN <列名><数据类型> ];**

​		其中 <表名> 是要修改的基本表，ADD 子句用于增加新列、新的列级完整性约束条件和新的表级完整性约束条件。DROP COLUMN 子句用于删除表中的列，如果指定了 CASCADE 短语，则自动删除引用了该列的其他对象，比如视图；如果指定了 RESTRICT 短语，则如果该列被其他对象引用，RDBMS 将拒绝删除该列。DROP CONSTRAINT 子句用于删除指定的完整性约束条件。ALTER COLUMN 子句用于修改原有的列定义，包括修改列名和数据类型。

​		**[例 3.8]**	向 Student 表增加 “入学时间” 列，其数据类型为日期型。

​				**ALTER TABLE Student ADD s_enterance DATE;**

不论基本表中原来是否已有数据，新增加的列一律为空值。

​		**[例 3.9]**	将年龄的数据类型由字符型（假设原来的数据类型是字符型）改为整数。

​				**ALTER TABLE Student ALTER COLUMN age INT;**
​				MySQL对应：**ALTER TABLE Student *MODIFY* COLUMN age INT;**

​		**[例 3.10]**	增加课程名称必须取唯一值的约束条件。

​				**ALTER TABLE Course ADD UNIQUE(Cname);**

​		**5.删除基本表**

​		当某个基本表不再需要时，可以使用DROP TABLE 语句删除它。其一般格式为：

​				***DROP TABLE <表名> [ RESTRICT|CASCADE ];***

​		若选择RESTRICT，则该表的删除是有限制条件的。欲删除的基本表不能被其他表的约束所引用（如 CHECK,FOREIGN KEY等约束)，不能有视图,不能有触发器(trigger)，不能有存储过程或函数等。如果存在这些依赖该表的对象，则此表不能被删除。
​		若选择CASCADE，则该表的删除没有限制条件。在删除基本表的同时，相关的依赖对象,例如视图，都将被一起删除。
​		默认情况是RESTRICT。

#### 3.2.3 索引的建立与删除

​		当表的数据量比较大时，查询操作会比较耗时。建立索引是加快查询速度的有效手段。数据库索引类似于图书后面的索引，能快速定位到需要查询的内容。用户可以根据应用环境的需要在基本表上建立一个或多个索引，以提供多种存取路径，加快查找速度。
​		数据库索引有多种类型，常见索引包括 **顺序文件上的索引**、**B+树索引**、**散列（hash）索引**、**位图索引** 等。

- **顺序文件上的索引：**针对按指定属性值升序或降序存储的关系，在该属性上建立一个顺序索引文件,索引文件由属性值和相应的元组指针组成。

- **B+树索引：**将索引属性组织成B+树形式，B+树的叶结点为属性值和相应的元组指针。B+树索引具有动态平衡的优点。散列索引是建立若干个桶，将索引属性按照其散列函数值映射到相应桶中，桶中存放索引属性值和相应的元组指针。散列索引具有查找速度快的特点。

- **位图索引：**用位向量记录索引属性中可能出现的值,每个位向量对应一个可能值。

​		索引虽然能够加速数据库查询，但需要占用一定的存储空间，当基本表更新时，索引要进行相应的维护，这些都会增加数据库的负担，因此要根据实际应用的需要有选择地创建索引。

​		**1.建立索引**
​		在SQL语言中，建立索引使用CREATE INDEX语句，其一般格式为：

​				**CREATE [UNIQUE] [CLUSTER] INDEX <索引名>**
​				**ON <表名>(<列名> [<次序>] [，<列名> [ <次序> ] ] …);**

​		其中，<表名>是要建索引的基本表的名字。索引可以建立在该表的一列或多列上，各列名之间用逗号分隔。每个<列名>后面还可以用<次序>指定索引值的排列次序，可选 ASC（升序）或 DESC（降序），默认值为 ASC。
​		UNIQUE表明此索引的每一个索引值只对应唯一的数据记录。
​		CLUSTER表示要建立的索引是聚簇索引。有关聚簇索引的概念在第7章7.5.2小节关系模式存取方法选择中介绍。

​		**[例 3.11]**	为学生-课程数据库中的 Student、Course 和 SC 三个表建立索引。其中 Student 表按学号升序建唯一索引，Course 表按课程号升序建唯一索引，SC 表按学号升序和课程号降序建唯一索引。

​				**CREATE UNIQUE INDEX Stusno ON Student(Sno);**
**​				CREATE UNIQUE INDEX Coucno ON Course(Cno);**
**​				CREATE UNIQUE INDEX SCno ON SC(Sno ASC,Cno DESC);**

​		**2.修改索引**
​		对于已经建立的索引，如果需要对其重新命名，可以使用 ALTER INDEX 语句。其一般格式为：

​				***ALTER INDEX <旧索引名> RENAME TO <新索引名>;***

​		**[例 3.12]**	将 SC 表的 SCno 索引名改为 SCSno。

​				**ALTER INDEX SCno RENAME TO SCSno;**

​		**3.删除索引**
​		索引一经建立就由系统使用和维护，不需用户干预。建立索引是为了减少查询操作的时间，但如果数据增、删、改频繁，系统会花费许多时间来维护索引，从而降低了查询效率。这时可以删除一些不必要的索引。
​		在SQL中，删除索引使用DROP INDEX语句，其一般格式为：

​				***DROP INDEX <索引名>**;*

​		**[例 3.13]**	删除 Student 表的 Sname 索引。

​				**DROP INDEX Sname;**
​				MySQL对应：**DROP INDEX Sname on Student;**

​		删除索引时，系统会同时从数据字典中删去有关该索引的描述。

#### 3.2.4 数据字典

​		数据字典是关系数据库管理系统内部的一组系统表，它记录了数据库中所有的定义信息，包括关系模式定义、视图定义、索引定义、完整性约束定义、各类用户对数据库的操作权限、统计信息等。关系数据库管理系统在执行 SQL 的数据定义语句时，实际上就是在更新数据字典表中的相应信息。在进行查询优化和查询处理时，数据字典中的信息是其重要依据。

### 3.3 数据查询

​		数据查询是数据库的核心操作。SQL 提供了 SELECT 语句进行数据查询，该语句具有灵活的使用方式和丰富的功能。其一般格式为：

​				**SELECT [ALL DISTINCT] <目标列表达式> [,<目标列表达式>] …**
**​				FROM <表名或视图名> [,<表名或视图名>…] | (<SELECT 语句>) [AS] <别名>** 
**​				[ WHERE<条件表达式> ]**
**​				[ GROUP BY <列名 1> [ HAVING <条件表达式> ] ]**
**​				[ ORDER BY <列名 2> [ ASC | DESC ] ];**

​		整个SELECT 语句的含义是，根据 WHERE 子句的条件表达式从：FROM 子句指定的基本表、视图或派生表中找出满足条件的元组，再按 SELECT 子句中的目标列表达式选出元组中的属性值形成结果表。
​		如果有 GROUP BY 子句，则将结果按<列名 1>的值进行分组，该属性列值相等的元组为一个组。通常会在每组中作用聚集函数。如果 GROUP BY 子句带 HAVING 短语，则只有满足指定条件的组才予以输出。
​		如果有 ORDER BY 子句，则结果表还要按<列名 2>的值的升序或降序排序。

#### 3.3.1 单表查询

​		单表查询是指仅涉及一个表的查询。

​		**1.选择表中的若干列**
​		选择表中的全部或部分列即关系代数的投影运算。

​		(1) 查询指定列
​		在很多情况下，用户只对表中的一部分属性列感兴趣，这时可以通过在 SELECT 子句的<目标列表达式>中指定要查询的属性列。

​		**[例 3.14]**	查询全体学生的学号与姓名。

```mysql
SELECT Sno,Sname FROM student
```

​		(2) 查询全部列
​		将表中的所有属性列都选出来有两种方法，一种方法就是在SELECT 关键字后列出所有列名;如果列的显示顺序与其在基表中的顺序相同，也可以简单地将<目标列表达式>指定为 *****。其一般格式为：

​				**SELECT * FROM <表名>;**

​		(3)查询经过计算的值
​		SELECT 子句的<目标列表达式>不仅 **可以是表中的属性列，也可以是表达式**。

​		**[例3.15]**	查询全体学生的姓名及其出生年份。

```mysql
SELECT Sname, 2022-Sage FROM student;
```

​		查询结果中第 2 列不是列名而是一个计算表达式，是用当时的年份（假设为 2022 年）减去学生的年龄。这样所得的即是学生的出生年份。输出的结果为：

| Sname  | 2022-Sage |
| :----: | :-------: |
| 陈致超 |   1998    |
| 邓时凯 |   2000    |
|  胡澳  |   1999    |
| 华云龙 |   1999    |

​		**2.选择表中的若干元组**
​		(1）消除取值重复的行
​		两个本来并不完全相同的元组在投影到指定的某些列上后，可能会变成相同的行。可以用 **DISTINCT** 消除它们。

​		**[例3.16]**	查询选修了课程的学生学号。

```mysql
SELECT DISTINCT Sno FROM sc;
```

​		(2）查询满足条件的元组
​		查询满足指定条件的元组可以通过WHERE子句实现。WHERE子句常用的查询条件如下表所示：

| 查询条件             |                        谓词                         |
| :------------------- | :-------------------------------------------------: |
| 比较                 | =，>，<，>=，<=，!=，<>，!>，!<；NOT+上述比较运算符 |
| 确定范围             |            BETWEEN AND，NOT BETWEEN AND             |
| 确定集合             |                     IN，NOT IN                      |
| 字符匹配             |                   LIKE，NOT LIKE                    |
| 空值                 |                IS NULL，IS NOT NULL                 |
| 多重条件（逻辑运算） |                    AND，OR，NOT                     |

​		① 比较大小
​		用于进行比较的运算符一般包括 =(等于)，>(大于)，<(小于)，>=(大于等于)，<=(小于等于)，!=或<>(不等于)，!>(不大于)，!<(不小于)。

​		**[例3.17]**	查询计算机科学系所有年龄 22 岁以上的学生姓名及其年龄。

```mysql
SELECT
	Sname,Sage
FROM
	student
WHERE
	Sage > 22 AND Sdept = 'CS'
```

​		② 确定范围
​		谓词 BETWEEN…AND… 和 NOT BETWEEN…AND… 可以用来查找属性值在（或不在）指定范围内的元组，其中 BETWEEN 后是范围的下限（即低值），AND 后是范围的上限（即高值）。

​		**[例3.18]**	查询年龄在 20~23 岁 (包括20岁和23岁) 之间的学生的姓名、系别和年龄。

```mysql
SELECT 
	Sname,Sdept,Sage
FROM 
	Student
WHERE 
	Sage BETWEEN 20 AND 23
```

​		③ 确定集合
​		谓词 IN 可以用来查找属性值属于指定集合的元组。

​		**[例3.18]**	查询计算机科学系（CS）和数学系（MA）学生的姓名和性别。

```mysql
SELECT 
	Sname,Ssex
FROM 
	student
WHERE 
	Ssdept IN ('CS','MA');
```

​		④ 字符匹配
​		谓词LIKE可以用来进行字符串的匹配。其一般语法格式如下：

​				**[NOT] LIKE '<匹配串>' [ ESCAPE '<换码字符>' ]**

其含义是查找指定的属性列值与<匹配串>相匹配的元组。<匹配串>可以是一个完整的字符串，也可以含有通配符 % 和 _。其中：
- %（百分号）代表任意长度（长度可以为0）的字符串。例如 a%b 表示以 a 开头，以 b 结尾的任意长度的字符串。如 acb、addgb、ab 等都满足该匹配串。
- _（下划线）代表任意单个字符。例如 a_b 表示以 a 开头，以 b 结尾的长度为 3 的任意字符串。如 acb、afb 等都满足该匹配串。

​		**[例3.19]**	查询以 “DB_” 开头，且倒数第三个字符为 i 的课程的详细情况。

```mysql
SELECT *
FROM Course
WHERE
	Cname LIKE 'DB\_%i_ _'ESCAPE '\';
```

​		**ESCAPE** ' \ ' 表示 “\” 为换码字符。这样匹配串中紧跟在 “\” 后面的字符 “ _ ” 不再具有通配符的含义，转义为普通的 “ _ ” 字符。这里的匹配串为 “DB\_%i_ _ ”。第一个 _ 前面有换码字符 \，所以它被转义为普通的字符。而i后面的两个 _ 的前面均没有换码字符 \，所以它们仍作为通配符。

​		⑤ 涉及空值的查询
​		**[例3.20]**	某些学生选修课程后没有参加考试，所以有选课记录，但没有考试成绩。查询缺少成绩的学生的学号和相应的课程号。

```mysql
SELECT
	Sno,Cno
FROM
	SC
WHERE
	Grade is null;		/*分数Grade是空值*/
```

​		⑥ 多重条件查询
​		逻辑运算符 AND 和 OR 可用来连接多个查询条件。AND 的优先级高于 OR ，但用户可以用括号改变优先级。

​		**[例3.21]**	查询计算机科学系（CS）年龄在 23 岁以下的学生姓名。

```mysql
SELECT 
	Sname
FROM 
	Student
WHERE 
	Sdept='CS' AND Sage<23
```

​		**3. ORDER BY 子句**
​		用户可以用 ORDER BY 子句对查询结果按照一个或多个属性列的升序（ASC）或降序（DESC）排列，默认值为升序。

​		**[例3.22]**	查询全体学生学号和姓名，查询结果按所在系的系号升序排列，同一系中的学生按年龄降序排列。按分数的降序排列。

```mysql
SELECT
	Sno,
	Sname
FROM
	student
	order by Sdept,Sage DESC;
```

​		**4.聚合函数**

​		为了进一步方便用户，增强检索功能，SQL 提供了许多聚集函数，主要有：

| 聚合函数                           |                  含义                  |
| ---------------------------------- | :------------------------------------: |
| COUNT(*)                           |              统计元组个数              |
| COUNT( [ DISTINCT \| ALL ] <列名>) |       统计一列中（不同）值的个数       |
| SUM( [ DISTINCT \| ALL ] <列名>)   |  计算一列值的总和（此列必须是数值型）  |
| AVG( [ DISTINCT \| ALL ] <列名>)   | 计算一列值的平均值（此列必须是数值型） |
| MAX( [ DISTINCT \| ALL ] <列名>)   |           求一列值中的最大值           |
| MIN( [ DISTINCT \| ALL ] <列名>)   |           求一列值中的最小值           |

​		如果指定 DISTINCT 短语，则表示在计算时要取消指定列中的重复值。如果不指定 DISTINCT 短语或指定 ALL 短语（ALL为默认值），则表示不取消重复值。
​		当聚集函数遇到空值时，除 COUNT( * ) 外，都跳过空值而只处理非空值。COUNT (*) 是对元组进行计数，某个元组的一个或部分列取空值不影响 COUNT 的统计结果。

> 注意！！！WHERE 子句中是不能用聚集函数作为条件表达式的。聚集函数只能用于 SELECT 子句和 GROUP BY 中的 HAVING 子句。
>

​		**4. GROUP BY 子句**
​		GROUP BY 子句将查询结果按某一列或多列的值分组，值相等的为一组。
​		**对查询结果分组的目的是为了细化聚集函数的作用对象**。如果未对查询结果分组，聚集函数将作用于整个查询结果。**分组后聚集函数将作用于每一个组，即每一组都有一个函数值**。

​		**[例3.23]**	求各个课程号及相应的选课人数。

```mysql
SELECT
	Cno,COUNT(Sno)
FROM
	sc
	group by Cno
```

​		查询结果为：

| Cno  | COUNT(Sno) |
| :--: | :--------: |
|  1   |     2      |
|  2   |     2      |
|  3   |     2      |
|  5   |     1      |

​		如果分组后还要求按一定的条件对这些组进行筛选，最终只输出满足指定条件的组,则可以使用 HAVING 短语指定筛选条件。

​		**[例3.24]**	查询选修了两门以上课程的学生学号。

```mysql
SELECT 
	Sno
FROM
	sc
	group by Sno
	HAVING Count(*)>2
```

​		这里先用 GROUP BY 子句按 Sno 进行分组，再用聚集函数 COUNT 对每一组计数；HAVING 短语给出了选择组的条件，只有满足条件（即 元组个数>3，表示此学生选修的课超过 3 门）的组才会被选出来。
​		WHERE 子句与 HAVING 短语的区别在于作用对象不同。WHERE 子句作用于基本表或视图，从中选择满足条件的元组。HAVING 短语作用于组，从中选择满足条件的组。

​		**[例3.25]**	查询平均成绩大于等于 90 分的学生学号和平均成绩。

```mysql
SELECT
	Sno,
	AVG(Grade)
FROM
	sc
	group by Sno
	HAVING AVG(Grade)>=90
```

#### 3.3.2 连接查询

​		前面的查询都是针对一个表进行的。若一个查询同时涉及两个以上的表，则称之为连接查询。连接查询是关系数据库中最主要的查询，包括等值连接查询、自然连接查询、非等值连接查询、自身连接查询、外连接查询和复合条件连接查询等。

​		**1.等值与非等值连接查询**
​		连接查询的WHERE子句中用来连接两个表的条件称为连接条件或连接谓词，其一般格式为：

​				**[<表名 1>.] <列名 1><比较运算符> [<表名 2>.] <列名2>**

其中比较运算符主要有=、>、<、>=、<=、!=（或<>）等。
​		此外连接谓词还可以使用下面形式：

​				**[<表名 1>.] <列名 1> BETWEEN [<表名 2>.] <列名 2> AND [<表名 2>.] <列名 3>**

​		当连接运算符为 = 时，称为 **等值连接**。使用其他运算符称为 **非等值连接**。
​		**连接谓词中的列名称为连接字段**。连接条件中的 **各连接字段类型必须是可比的**，但名字不必相同。

​		**<a name="3.26">[例3.26]</a>**	查询每个学生及其选修课程的情况。

```mysql
SELECT
	student.*,
	sc.*
FROM
	student,sc
WHERE
	student.Sno = sc.Sno;
```

​		关系数据库管理系统执行该连接操作的一种可能过程是：首先在表 Student 中找到第一个元组，然后从头开始扫描 SC 表，逐一查找与 Student 第一个元组的 Sno 相等的SC元组，找到后就将 Student 中的第一个元组与该元组拼接起来，形成结果表中一个元组。SC 全部查找完后，再找 Student 中第二个元组，然后再从头开始扫描 SC，逐一查找满足连接条件的元组，找到后就将 Student 中的第二个元组与该元组拼接起来，形成结果表中一个元组。重复上述操作，直到 Student 中的全部元组都处理完毕为止。这就是嵌套循环连接算法的基本思想。如下图所示。

![image-20220224133621601](https://gitee.com/enchantedqaq/cloudimage/raw/master/img/image-20220224133621601.png)

​		如果在 SC 表 Sno 上建立了索引的话，就不用每次全表扫描 SC 表了，而是 **根据 Sno 值通过索引找到相应的 SC 元组。用索引查询 SC 中满足条件的元组一般会比全表扫描快**。若在等值连接中 **把目标列中重复的属性列去掉则为自然连接**。
​		一条 SQL 语句可以同时完成选择和连接查询,这时 **WHERE 子句是由连接谓词和选择谓词组成的复合条件**。

​		**[例3.27]**	查询选修 2 号课程且成绩在 90 分以上的所有学生的学号和姓名。

```mysql
SELECT
	student.Sno,
	student.Sname
FROM
	student,sc
WHERE
	student.Sno = sc.Sno					/*连接谓词 */
	AND sc.Cno = '2' AND sc.Grade > 90;		/*其他限定条件 */
```

​		该查询的 **一种优化（高效）的执行过程是，先从 SC 中挑选出 Cno = '2' 并且 Grade > 90 的元组** 形成一个中间关系，再和 Student 中满足连接条件的元组进行连接得到最终的结果关系。

​		**2.自身连接**
​		连接操作不仅可以在两个表之间进行，也可以是一个表与其自己进行连接，称为表的自身连接。

​		**[例3.27]**	查询每一门课的间接先修课（即先修课的先修课）。
​		在 Course 表中只有每门课的直接先修课信息，而没有先修课的先修课。要得到这个信息，必须先对一门课找到其先修课，再按此先修课的课程号查找它的先修课程。这就要将 Course 表与其自身连接。
​		为此，要为 Course 表取两个别名，一个是 FIRST，另一个是 SECOND。

![image-20220224135422046](https://gitee.com/enchantedqaq/cloudimage/raw/master/img/image-20220224135422046.png)

```mysql
SELECT
	FIRST.Cno,
	SECOND.Cpno
FROM
	Course FIRST,Course SECOND
WHERE
	FIRST.Cpno = SECOND.Cno;
```

​		**3.外连接**
​		在通常的连接操作中，只有满足连接条件的元组才能作为结果输出。如 <a href="#3.26">例3.26</a> 的结果表中没有 201215123 和 201215125 两个学生的信息，原因在于他们没有选课，在 SC 表中没有相应的元组，导致 Student 中这些元组在连接时被舍弃了。
​		有时想以 Student 表为主体列出每个学生的基本情况及其选课情况。若某个学生没有选课，仍把 Student 的悬浮元组保存在结果关系中，而在 SC 表的属性上填空值NULL，这时就需要使用外连接。

​		**[例3.28]**	使用外连接查询每个学生及其选修课程的情况。

```mysql
SELECT
	student.Sno,
	student.Sname,
	student.Sex,
	student.Sage,
	student.Sdept,
	sc.Cno,
	sc.Grade
FROM
	student LEFT JOIN sc ON student.Sno = sc.Sno;
```

​		**左外连接** 列出左边关系（如本例 Student）中所有的元组，**右外连接** 列出右边关系中所有的元组。

​		**4.多表连接**
​		连接操作除了可以是 **两表连接**、一个表与其自身连接外，还可以是两个以上的表进行连接，后者通常称为 **多表连接**。

​		**[例3.29]**	查询每个学生的学号、姓名、选修的课程名及成绩。

```mysql
SELECT
	student.Sno,
	student.Sname,
	course.Cname,
	sc.Grade
FROM
	student,course,sc
WHERE
	student.Sno = sc.Sno AND sc.Cno = course.Cno
```

​		关系数据库管理系统在执行多表连接时，通常是先进行两个表的连接操作，再将其连接结果与第三个表进行连接。本例的一种可能的执行方式是，先将 Student 表与 SC 表进行连接，得到每个学生的学号、姓名、所选课程号和相应的成绩，然后再将其与 Course 表进行连接，得到最终结果。

#### 3.3.3 嵌套查询

​		在 SQL 语言中，**一个 SELECT-FROM-WHERE 语句称为一个查询块**。将一个查询块嵌套在另一个查询块的 WHERE 子句或 HAVING 短语的条件中的查询称为 **嵌套查询（nestedquery）**。例如：

```mysql
SELECT Sname				/*外层查询或父查询 */			
FROM student
WHERE
	Sno IN 
	(SELECT Sno 			/*内层查询或子查询 */
     FROM sc 
     WHERE Cno = '2');
```

​		本例中，下层查询块 SELECT Sno FROM SC WHERE Cno=2' 是嵌套在上层查询块 SELECT Sname FROM Student WHERE Sno IN 的 WHERE 条件中的。上层的查询块称为 **外层查询** 或 **父查询**，下层查询块称为 **内层查询** 或 **子查询**。
​		SQL 语言允许多层嵌套查询，即一个子查询中还可以嵌套其他子查询。需要特别指出的是，**子查询的 SELECT 语句中不能使用 ORDER BY 子句，ORDER BY 子句只能对最终查询结果排序**。
​		嵌套查询使 **用户可以用多个简单查询构成复杂的查询**，从而增强 SQL 的查询能力。**以层层嵌套的方式来构造程序正是 SQL 中“结构化”的含义所在**。

​		**1.带有 IN 谓词的子查询**
​		在嵌套查询中，子查询的结果往往是一个集合，所以谓词 IN 是嵌套查询中最经常使用的谓词。

​		**<a name="3.30">[例3.30]</a>**	查询与 “陈致超” 在同一个系学习的学生。

> ​	先分步来完成此查询，然后再构造嵌套查询。

​		① 确定 “陈致超” 所在系名
​				SELECT Sdept
​				FROM student
​				WHERE Sname = '陈致超';
结果为 CS。
​		② 查找所有在 CS 系学习的学生。
​				SELECT Sno,Sname,Sdept
​				FROM student
​				WHERE Sdept = 'CS';
结果为：

|    Sno     | Sname  | Sdept |
| :--------: | :----: | :---: |
| 1710050103 | 陈致超 |  CS   |
| 1710050104 | 邓时凯 |  CS   |

​		**解法一**：将第一步查询嵌入到第二步查询的条件中，构造嵌套查询如下:

```mysql
SELECT 
	Sno,Sname,Sdept	
FROM 
	student
WHERE Sdept IN 
	 (SELECT Sdept
      FROM student
      WHERE Sname = '陈致超')；
```

​		本例中，**子查询的查询条件不依赖于父查询，称为不相关子查询**。一种求解方法是由里向外处理，即先执行子查询，子查询的结果用于建立其父查询的查找条件。

​		**解法二**：本例中的查询也可以用自身连接来完成。

```mysql
SELECT 
	S1.Sno,S1.Sname,S1.Sdept
FROM
	student S1,student S2
WHERE
	S1.Sdept = S2.Sdept AND s2.Sname = '陈致超';
```

​		可见，**实现同一个查询请求可以有多种方法**，当然不同的方法其执行效率可能会有差别，甚至会差别很大。这就是数据库编程人员应该掌握的 **数据库性能调优技术**，有兴趣的读者可以参考本章相关文献资料和具体产品的性能调优方法。

​		**[例3.31]**	查询选修了课程名为 “信息系统” 的学生学号和姓名。

```mysql
方法一：
    SELECT
        student.Sno,student.Sname
    FROM
        student
    WHERE
        student.Sno IN
        (SELECT	sc.Sno 
         FROM sc
         WHERE sc.Cno IN 
            (SELECT course.Cno
             FROM course
             WHERE course.Cname = '信息系统'
            )
        );
方法二：
    SELECT
        student.Sno,student.Sname
    FROM
        student,sc,course
    WHERE
        student.Sno = sc.Sno AND sc.Cno = course.Cno AND course.Cname = '信息系统'
```

​		**有些嵌套查询可以用连接运算替代，有些是不能替代的**。从上面两个例子可以看到，查询涉及多个关系时，用嵌套查询逐步求解层次清楚，易于构造，具有结构化程序设计的优点。但是相比于连接运算，目前商用关系数据库管理系统对嵌套查询的优化做得还不够完善，所以在实际应用中，**能够用连接运算表达的查询尽可能采用连接运算**。
​		上面例子中子查询的查询条件不依赖于父查询，这类子查询称为 **不相关子查询**。不相关子查询是较简单的一类子查询。**如果子查询的查询条件依赖于父查询，这类子查询称为相关子查询（correlated subquery）**，整个查询语句称为 **相关嵌套查询（correlatednested query）**语句。

​		**2.带有比较运算符的子查询**
​		带有比较运算符的子查询是指父查询与子查询之间用比较运算符进行连接。当用户能确切知道内层查询返回的是单个值时，可以用 >、<、=、>=、<=、!= 或 <> 等比较运算符。

​		**[例3.32]**	找出每个学生超过他自己选修课程平均成绩的课程号。

```mysql
SELECT
	sc.Sno,sc.Cno
FROM
	sc x
WHERE
	sc.Grade >= (SELECT AVG(Grade)			/*某学生的平均成绩 */
                 FROM sc y
                 WHERE y.Sno = x.Sno);
```

​		x 是表 SC 的别名，又称为元组变量，可以用来表示 SC 的一个元组。内层查询是求一个学生所有选修课程平均成绩的，至于是哪个学生的平均成绩要看 **参数 x.Sno 的值，而该值是与父查询相关的，因此这类查询称为相关子查询**。
​		这个语句的一种可能的执行过程采用以下三个步骤。
​		① 从外层查询中取出 SC 的一个元组 x，将元组 x 的 Sno 值（1710050103）传送给内层查询。
​				SELECT AVG(Grade)
​				FROM sc y
​				WHERE y.Sno = '1710050103';
​		② 执行内层查询，得到值 91（近似值），用该值代替内层查询，得到外层查询：
​				SELECT Sno,Cno
​				FROM sc x
​				WHERE Grade >= 91;
​		③ 执行这个查询，得到
​				(1710050103，1)
​		然后外层查询取出下一个元组重复做上述①至③步骤的处理，直到外层的 SC 元组全部处理完毕。结果为：
​				(1710050103，1)
​				(1710050104，1)
​				(1710050104，3)
​				(1710050105，2)
​				(1710050106，5)
​		**求解相关子查询不能像求解不相关子查询那样一次将子查询求解出来，然后求解父查询**。内层查询由于与外层查询有关，因此必须反复求值。

​		**3.带有 ANY（SOME）或 ALL 谓词的子查询**
​		子查询返回单值时可以用比较运算符，但返回多值时要用 ANY（有的系统用 SOME）或 ALL 谓词修饰符。而使用 ANY 或 ALL 谓词时则必须同时使用比较运算符。其语义如下所示：

![image-20220224164807709](https://gitee.com/enchantedqaq/cloudimage/raw/master/img/image-20220224164807709.png)

​		**[例3.33]**	查询非计算机科学系中比计算机科学系所有一个学生年龄小的学生姓名和年龄。

```mysql
SELECT
	student.Sname,student.Sage
FROM
	student
WHERE
	student.Sage < ALL(SELECT student.Sage
                       FROM student
                       WHERE student.Sdept = 'CS')
    AND student.Sdept <> 'CS';			/*注意这是父查询块中的条件 */
```

​		关系数据库管理系统执行此查询时，首先处理子查询，找出 CS 系中所有学生的年龄，构成一个集合 (24,22)；然后处理父查询，找所有不是 CS 系且年龄小于 24 或 22 的学生。
​		本查询也可以用聚集函数来实现，首先用子查询找出 CS 系中最小年龄 (22) ，然后在父查询中查所有非 CS 系且年龄小于 22 岁的学生。SQL 语句如下:

```mysql
SELECT
	student.Sname,student.Sage
FROM
	student
WHERE
	student.Sage < (SELECT MIN(Sage)
                    FROM student
                   	WHERE student.Sdept = 'CS')
    AND student.Sdept <> 'CS';			/*注意这是父查询块中的条件 */
```

​		事实上，**用聚集函数实现子查询通常比直接用 ANY 或 ALL 查询效率要高**。ANY、ALL 与聚集函数的对应关系如下图所示：

![image-20220224173142118](https://gitee.com/enchantedqaq/cloudimage/raw/master/img/image-20220224173142118.png)

​		=ANY 等价于 IN 谓词，<ANY 等价于 <MAX，<>ALL 等价于 NOT IN 谓词，<ALL 等价于 <MIN，等等。

​		**4.带有 EXISTS 谓词的子查询**
​		EXISTS 代表存在量词 ∃。**带有 EXISTS 谓词的子查询不返回任何数据，只产生逻辑真值 “true” 或逻辑假值 “false”**。
​		可以利用 EXISTS 来判断 x∈S、S⊆R、S=R、S∩R 非空等是否成立。

​		**[例3.34]**	查询所有选修了 1 号课程的学生姓名。

​		本查询涉及 Student 和 SC 表。可以在 Student 中依次取每个元组的 Sno 值，用此值去检查 SC 表。若 SC 中存在这样的元组，其 Sno 值等于此 Student.Sno 值，并且其 Cno='1'，则取此 Student.Sname 送入结果表。将此想法写成 SQL 语句是：

```mysql
SELECT
	Sname
FROM
	student
WHERE EXISTS
	(SELECT *
     FROM sc
     WHERE sc.Sno = student.Sno AND Cno = '1');
```

​		使用存在量词 EXISTS 后，**若内层查询结果非空，则外层的 WHERE 子句返回真值，否则返回假值**。
​		由 EXISTS 引出的子查询，其目标列表达式通常都用 *，因为带 EXISTS 的子查询只返回真值或假值，给出列名无实际意义。
​		本例中 **子查询的查询条件依赖于外层父查询的某个属性值（Student 的 Sno 值），因此也是相关子查询**。这个相关子查询的处理过程是：首先取外层查询中 Student 表的第一个元组，根据它与内层查询相关的属性值（Sno 值）处理内层查询，若 WHERE 子句返回值为真，则取外层查询中该元组的 Sname 放入结果表；然后再取 Student 表的下一个元组；重复这一过程，直至外层 Student 表全部检查完为止。
​		本例中的查询也可以用连接运算来实现，读者可以参照有关的例子自己给出相应的 SQL 语句。
​		与 EXISTS 谓词相对应的是 NOT EXISTS 谓词。**使用存在量词 NOT EXISTS 后，若内层查询结果为空，则外层的 WHERE 子句返回真值，否则返回假值**。
​		一些带 EXISTS 或 NOT EXISTS 谓词的子查询不能被其他形式的子查询等价替换，但所有带 IN 谓词、比较运算符、ANY 和 ALL 谓词的子查询都能用带 EXISTS 谓词的子查询等价替换。例如带有 IN 谓词的 <a href="#3.30">[例3.30]</a> 可以用如下带 EXISTS 谓词的子查询替换：

```mysql
SELECT
	S1.Sno,S1.Sname,S1.Sdept
FROM
	student S1
WHERE EXISTS
	(SELECT *
     FROM student S2
     WHERE S1.Sdept = S2.Sdept AND S2.Sname = '陈致超');
```

​		由于 **带 EXISTS 量词的相关子查询只关心内层查询是否有返回值，并不需要查具体值，因此其效率并不一定低于不相关子查询，有时是高效的方法**。

​		**[例3.35]**	查询选修了全部课程的学生姓名。
​		SQL 中没有全称量词（for all )，但是可以把带有全称量词的谓词转换为等价的带有存在量词的谓词：
​				**( ∀x )P≡ ┐(∃x (┐P))**
​		由于没有全称量词，可将题目的意思转换成等价的用存在量词的形式：查询这样的学生，**没有一门课程是他不选修的**。其 SQL 语句如下:

```mysql
SELECT
	Sname
FROM
	student
WHERE NOT EXISTS
	(SELECT *
     FROM course
     WHERE NOT EXISTS
     	(SELECT *
         FROM sc
         WHERE sc.Sno = student.Sno AND course.Cno = sc.Cno
        )
    );
```

​		从而用 EXIST/NOT EXIST 来实现带全称量词的查询。

​		**[例3.35]**	查询至少选修了学生 1710050103 选修的全部课程的学生号码。
​		本查询可以用逻辑蕴涵来表达：查询学号为 x 的学生，对所有的课程 y ，只要 1710050103 学生选修了课程 y，则 x 也选修了 y。形式化表示如下：
​		用 p 表示谓词 ”学生 1710050103 选修了课程 y“
​		用 q 表示谓词 ”学生 x 选修了课程 y“
则上述查询为：
​				**(∀y)p→q**
​		SQL 语言中没有蕴涵（implication）逻辑运算，但是可以利用谓词演算将一个逻辑蕴涵的谓词等价转换为：
​				**p→q≡ ┐p⋁q**
​		该查询可以转换为如下等价形式：
​				**(∀y)p→q≡┐(∃y(┐(p→q)))≡┐(∃y(┐(┐p⋁q)))≡┐∃y(p⋀┐q)**
​		它所表达的语义为：不存在这样的课程 y，学生 1710050103 选修了 y，而学生 x 没有选。用 SQL 语言表示如下：

```mysql
SELECT DISTINCT
	scx.Sno
FROM
	sc scx
WHERE NOT EXISTS
	(SELECT *
     FROM sc scy
     WHERE SCY.Sno = '1710050103' AND
    	NOT EXISTS
    	(SELECT *
         FROM sc scz
         WHERE scz.Sno = scx.Sno AND scz.Cno = scy.Cno
        )
    );
```

#### 3.3.4 集合查询













































































































































1.什么是模式(Schema)

​		对数据库中数据所进行的一种结构性的描述，所观察到数据的结构信息.

![image-20220207152122733](C:\Users\EnchantedQAQ\AppData\Roaming\Typora\typora-user-images\image-20220207152122733.png)

------

2.什么是视图(View）

​		某一种表现形式下表现出来的数据库中的数据

***模式(Schema)是对视图(View)的一个抽象***

***视图(View)是一种模式(Schema)下的展示的一组数据(对模式的具体)***

------

3.第一范式

​		属性不可再分

![image-20220209140308816](C:\Users\EnchantedQAQ\AppData\Roaming\Typora\typora-user-images\image-20220209140308816.png)



![image-20220209144009332](C:\Users\EnchantedQAQ\AppData\Roaming\Typora\typora-user-images\image-20220209144009332.png)
