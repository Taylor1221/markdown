# 第一篇 基础篇

## 第1章	绪论

### 1.1 数据库系统概述

#### 1.1.1 数据库的4个基本概念

**1. 数据（data）**

- 描述事物的符号记录称为数据。
- 数据的含义称为数据的语义，数据与其予以是不可分的。

**2. 数据库（DataBase，DB）**
​		**数据库是长期储存在计算机内、有组织的、可共享的大量数据的集合**。数据库中的数据按一定的数据模型组织、描述和储存，具有**较小的冗余度(redundancy)**、**较高的数据独立性（data independency）**和**易扩展性(scalability)**，并**可为各种用户共享**。数据库数据具有三个基本特点：

- **永久存储**
- **有组织**
- **可共享**

**3. 数据库管理系统（DataBase Management System，DBMS）**
​		数据库管理系统是位于用户与操作系统之间的一层数据管理软件。数据库管理系统和操作系统一样是**计算机的基础软件**，也是一个大型复杂的软件系统。它的主要功能包括以下几个方面:
​		**(1) 数据定义功能**
        数据库管理系统提供数据定义语言（Data Definition Language，DDL)，用户通过它可以方便地对数据库中的数据对象的组成与结构进行定义。
​		**(2) 数据组织、存储和管理**
​		数据库管理系统要分类组织、存储和管理各种数据，包括数据字典、用户数据、数据的存取路径等。要确定以何种文件结构和存取方式在存储级上组织这些数据，如何实现数据之间的联系。数据组织和存储的基本目标是提高存储空间利用率和方便存取，提供多种存取方法（如索引查找、hash查找、顺序查找等）来提高存取效率。
​		**(3) 数据操纵功能**
        数据库管理系统还提供数据操纵语言(（Data Manipulation Language，DML)，用户可以使用它操纵数据，实现对数据库的基本操作，如查询、插入、删除和修改等。
​		**(4) 数据库的事务管理和运行管理**
        数据库在建立、运用和维护时由数据库管理系统统一管理和控制，以保证事务的正确运行，保证数据的安全性、完整性、多用户对数据的并发使用及发生故障后的系统恢复。
​		**(5) 数据库的建议和维护功能**
​		**(6) 其他功能**

**4. 数据库系统（DataBase System，DBS）**

​		数据库系统是由**数据库**、**数据库管理系统**（及其应用开发工具）、**应用程序**和**数据库管理员**（DataBase Administrator,DBA)组成的**存储**、**管理**、**处理**和**维护数据**的**系统**。

#### 1.1.2 数据库系统的特点

- **数据结构化**
- **数据的共享性高、冗余度低且易扩充**
- **数据独立性高**
- **数据由数据库管理系统统一管理和控制**

### 1.2 数据模型

​		==数据模型（data model）==也是一种模型，它是**对现实世界数据特征的抽象**。也就是说**数据模型是用来描述数据、组织数据和对数据进行操作的**。

​		***数据模型是数据库系统的核心和基础。***

#### 1.2.1 两类数据模型

​		根据模型**应用目的不同**，可以将这些模型划分为两大类，它们分别属于两个不同的层次。**第一类是概念模型，第二类是逻辑模型和物理模型**。
​		**第一类概念模型（conceptual model)**，也称**信息模型**，它是按用户的观点来对数据和信息建模，主要**用于数据库设计**。
​		**第二类中的逻辑模型**主要包括**层次模型(hierarchical model)**、**网状模型(network model**、**关系模型（relational model)**、**面向对象数据模型（object oriented data model)**和**对象关系数据模型（object relational data model)**、**半结构化数据模型(semistructured data model)**等。它是按计算机系统的观点对数据建模，主要**用于数据库管理系统的实现**。

#### 1.2.2 概念模型

![image-20220212135504775](https://gitee.com/enchantedqaq/cloudimage/raw/master/img/image-20220212135504775.png)

​		概念模型实际上是现实世界到机器世界的一个中间层次，用于信息世界的建模，是现实世界到信息世界的第一层抽象。

​		**1. 信息世界中的基本概念**

​		(1) **实体 (entity)**
​		**客观存在并可相互区别的事物称为实体**。实体可以是具体的人、事、物，也可以是抽象的概念或联系，例如，一个职工、一个学生、一个部门、一门课、学生的一次选课、部门的一次订货、教师与院系的工作关系（即某位教师在某院系工作）等都是实体。

​		(2) **属性 (attribute)**
​		**实体所具有的某一特性称为属性**。一个实体可以由若干个属性来刻画。例如，学生实体可以由学号、姓名、性别、出生年月、所在院系、入学时间等属性组成，属性组合(201315121，张山，男，199505，计算机系，2013）即表征了一个学生。

​		(3) **码 (key)**
​		**唯一标识实体的属性集称为码**。例如学号是学生实体的码。

​		(4) **实体型 (entity type)**
​		**具有相同属性的实体必然具有共同的特征和性质**。用实体名及其属性名集合来抽象和刻画同类实体，称为实体型。例如，学生(学号，姓名，性别，出生年月，所在院系，入学时间)就是一个实体型。

​		(5) **实体集 (entity set)**
​		**同一类型实体的集合称为实体集**。例如，全体学生就是一个实体集。

​		(6) **联系 (relationship)**
​		在现实世界中，事物内部以及事物之间是有联系的，这些联系在信息世界中反映为实体（型）内部的联系和实体（型）之间的联系。实体内部的联系通常是指组成实体的各属性之间的联系，**实体之间的联系通常是指不同实体集之间的联系**。
​		实体之间的联系有 **一对一**、**一对多**和多对多等多种类型。

​		**2. 概念模型的一种表示方法：实体-联系方法**

​		概念模型是对信息世界建模，所以概念模型应该能够方便、准确地表示出上述信息世界中的常用概念。概念模型的表示方法很多，其中最为常用的是P.P.S.Chen于1976年提出的**实体-联系方法（Entity-Relationship approach)**。该方法用E-R图(E-R diagram)来描述现实世界的概念模型，**E-R方法也称为E-R模型**。

#### 1.2.3 数据模型的组成要素

​		一般地讲，数据模型是严格定义的一组概念的集合。这些概念精确地描述了系统的静态特性、动态特性和完整性约束条件(integrity constraints)。因此**数据模型通常由数据结构、数据操作和数据的完整性约束条件三部分组成**。

​		**1. 数据结构**
​		数据结构描述数据库的组成对象以及对象之间的联系。也就是说，数据结构描述的内容有两类:一类是与对象的类型、内容、性质有关的，如网状模型中的数据项、记录，关系模型中的域、属性、关系等;一类是与数据之间联系有关的对象，如网状模型中的系型( set type)。
​		数据结构是所描述的对象类型的集合，是对系统静态特性的描述。

​		**2. 数据操作**
​		数据操作是指对数据库中各种对象（型）的实例（值）允许执行的操作的集合，包括操作及有关的操作规则。
​		数据库主要有查询和更新（包括插入、删除、修改）两大类操作。数据模型必须定义这些操作的确切含义、操作符号、操作规则（如优先级）以及实现操作的语言。
​		
​		**3. 数据的完整性约束条件**
​		数据的完整性约束条件是一组完整性规则。完整性规则是给定的数据模型中数据及其联系所具有的制约和依存规则，用以限定符合数据模型的数据库状态以及状态的变化，以保证数据的正确、有效和相容。

#### 1.2.4 常用的数据模型

- **层次模型（hierarchical model）**
- **网状模型（network model）**
- **关系模型（relationship model）**
- **面向对象数据模型（object oriented data model）**
- **对象关系数据模型（object relational data model）**
- **半结构化数据模型（semistructure data model）**

#### 1.2.5 层次模型

**1. 层次模型的数据结构（树形结构）**

​		在数据库中定义满足下面两个条件的基本层次联系的集合为层次模型：
​		(1) **有且只有一个结点没有双亲结点，这个结点称为根结点;**
​		(2) **根以外的其他结点有且只有一个双亲结点。**

​		在层次模型中，==每个结点表示一个记录类型，记录类型之间的联系用结点之间的连线(有向边)表示，这种联系是父子之间的一对多的联系==。这就使得**层次数据库系统只能处理一对多的实体联系**。

**2. 层次模型的数据操作与完整性约束**

​		层次模型的数据操纵主要有查询、插入、删除和更新。进行插入、删除、更新操作时要满足层次模型的完整性约束条件。

- 进行插入操作时,如果没有相应的双亲结点值就不能插入它的子女结点值。
- 进行删除操作时，如果删除双亲结点值，则相应的子女结点值也将被同时删除。

**3. 层次模型的优缺点**

​	层次模型的==优点==主要有:

- **层次模型的数据结构比较简单清晰**。
- **层次数据库的查询效率高（通常用指针实现）**。
- **层次数据模型提供了良好的完整性支持**。

​	层次模型的==缺点==主要有:

- 现实世界中很多联系是非层次性的，如结点之间具有**多对多联系，不适合用层次模型表示**。
- 如果一个结点具有多个双亲结点等，用层次模型表示这类联系就很笨拙，只能通过引入冗余数据（易产生不一致性）或创建非自然的数据结构（引入虚拟结点）来解决。**对插入和删除操作的限制比较多**，因此应用程序的编写比较复杂。
- **查询子女结点必须通过双亲结点**。
- 由于结构严密,**层次命令趋于程序化**。

***==层次模型更适合一对多的层次联系！！！==***

#### 1.2.6 网状模型

​		网状数据库系统采用网状模型作为数据的组织方式。**网状数据模型的典型代表是DBTG系统,亦称CODASYL 系统**。

**1. 网状模型的数据结构**

​		在数据库中，把满足以下两个条件的基本层次联系集合称为网状模型:
​		(1) **允许一个以上的结点无双亲**。
​		(2) **一个结点可以有多于一个的双亲**。

​		网状模型是一种比层次模型更具普遍性的结构。它去掉了层次模型的两个限制，**允许多个结点没有双亲结点**，**允许结点有多个双亲结点**;此外它还**允许两个结点之间有多种联系**（称之为复合联系)。因此，网状模型可以更直接地去描述现实世界。而层次模型实际上是网状模型的一个特例。

**2. 网状模型的数据操作与完整性约束**

​		(1) **支持记录码的概念，码即唯一标识记录的数据项的集合**。例如，学生记录(（如图1.13）中学号是码,因此数据库中不允许学生记录中学号出现重复值。
​		(2) **保证一个联系中双亲记录和子女记录之间是一对多的联系**。
​		(3) **可以支持双亲记录和子女记录之间的某些约束条件**。例如，有些子女记录要求双亲记录存在才能插入，双亲记录删除时也连同删除。例如图1.13中选课记录就应该满足这种约束条件,学生选课记录值必须是数据库中存在的某一学生选修存在的某一门课的记录。DBTG提供了“属籍类别”的概念来描述这类约束条件。

**3. 网状模型的优缺点**

​	网状模型的==优点==主要有:

- **能够更为直接地描述现实世界，如一个结点可以有多个双亲，结点之间可以有多种联系**。
- **具有良好的性能,存取效率较高**。

​	网状模型的==缺点==主要有:

- **结构比较复杂**，而且随着应用环境的扩大，数据库的结构就变得越来越复杂，不利于最终用户掌握。
- **网状模型的DDL、DML复杂**,并且要嵌入某一种高级语言(如 COBOL、C)中用户不容易掌握,不容易使用。
- 由于记录之间的联系是通过存取路径实现的，应用程序在访问数据时必须选择适当的存取路径，因此**用户必须了解系统结构的细节，加重了编写应用程序的负担**。

#### 1.2.7 关系模型（最重要）

**1. 关系模型的数据结构**

​		**从用户观点看，关系模型由一组关系组成。每个关系的数据结构是一张规范化的二维表**。以学生登记表为例：

|   学  号   | 姓  名 | 年  龄 | 性  别 | 系  名 | 年  级 |
| :--------: | :----: | :----: | :----: | :----: | :----: |
| 1710050103 | 陈致超 |   23   |   男   | 社会学 |  2017  |
| 1710050104 | 邓时凯 |   21   |   女   | 商品学 |  2017  |
| 1710050105 |  胡澳  |   22   |   男   |  工学  |  2017  |
|     ……     |   ……   |   ……   |   ……   |   ……   |   ……   |

- **关系 (relation)**：**一个关系对应通常说的一张表**，例如上图的这张学生登记表。

- **元组 (tuple)**：**表中的一行即为一个元组**。

- **属性 (attribute)**：**表中的一列即为一个属性，给每一个属性起一个名称即属性名**。如上图的表有6列，对应6个属性（学号，姓名，年龄，性别，系名和年级)。

- **码 (key)**：**也称为码键。表中的某个属性组，它可以唯一确定一个元组**，如上图的学号可以唯一确定一个学生，也就成为本关系的码。

- **域 (domain)**：**域是一组具有相同数据类型的值的集合**。属性的取值范围来自某个域。如人的年龄一般在 1—120岁之间，大学生年龄属性的域是(15~45岁),性别的域是(男，女)，系名的域是一个学校所有系名的集合。

- **分量**：**元组中的一个属性值**。

- **关系模式**：对关系的描述，一般表示为: **关系名 (属性1，属性2，…，属性n)**

​		例如，上面的关系可描述为: 学生 (学号，姓名，年龄，性别，系名，年级)

​		关系模型要求关系必须是规范化的，即要求关系必须满足一定的规范条件，这些规范条件中最基本的一条就是，关系的每一个分量必须是一个不可分的数据项，也就是说，不允许表中还有表。例如，下图中工资和扣除是可分的数据项，工资又分为基本工资、岗位津贴和业绩津贴，扣除又分为三险和个人所得税。因此，下图的表就不符合关系模型要求。

![image-20220212164227516](https://gitee.com/enchantedqaq/cloudimage/raw/master/img/image-20220212164227516.png)

可以把关系和现实生活中的表格所使用的术语做一个粗略的对比：

| 关系术语   | 一般表格的术语             |
| ---------- | -------------------------- |
| 关系名     | 表名                       |
| 关系模式   | 表头（表格的描述）         |
| 关系       | (一张）二维表              |
| 元组       | 记录或行                   |
| 属性       | 列                         |
| 属性名     | 列名                       |
| 属性值     | 列值                       |
| 分量       | 一条记录中的一个列值       |
| 非规范关系 | 表中有表（大表中嵌有小表） |

**2. 关系模型的数据操作与完整性约束**

​		关系模型的数据操纵主要包括==查询==、==插入==、==删除==和==更新数据==。这些操作必须满足关系的完整性约束条件。关系的完整性约束条件包括三大类: **实体完整性**、**参照完整性**和**用户自定义完整性**。

​		关系模型中的数据操作是集合操作，**操作对象和操作结果都是关系**，**即若干元组的集合**，而不像格式化模型中那样是单记录的操作方式。另一方面，**关系模型把存取路径向用户隐蔽起来，用户只要指出“干什么”或“找什么”，不必详细说明“怎么干”或“怎么找”**,从而大大地提高了数据的独立性,提高了用户生产率。

**3. 关系模型的优缺点**

​	关系模型的==优点==主要有:

- 关系模型与格式化模型不同,它是**建立在严格的数学概念的基础上**的。
- **关系模型的概念单一**。无论实体还是实体之间的联系都用关系来表示。对数据的检索和更新结果也是关系（即表)。所以其数据结构简单、清晰，用户易懂易用。
- 关系模型的存取路径对用户透明，从而**具有更高的数据独立性、更好的安全保密性**,也简化了程序员的工作和数据库开发建立的工作。

​	关系模型的==缺点==:

​		由于存取路径对用户是隐蔽的，**查询效率往往不如格式化数据模型**。为了提高性能，数据库管理系统必须对用户的查询请求进行优化，因此增加了开发数据库管理系统的难度。

### 1.3 数据库系统的结构

​		从数据库应用开发人员角度看，**数据库系统通常采用三级模式结构，这是数据库系统内部的系统结构**。从数据库最终用户角度看，数据库系统的结构分为单用户结构、主从式结构、分布式结构、客户-服务器、浏览器-应用服务器/数据库服务器多层结构等。这是数据库系统外部的体系结构。
​		本章介绍数据库系统的模式结构。

#### 1.3.1 数据库系统模式的概念

​		**在数据模型中有“型”(type) 和“值”(value) 的概念**。**型是指对某一类数据的结构和属性的说明，值是型的一个具体赋值**。例如，学生记录定义为(学号，姓名，性别，系别，年龄，籍贯）这样的记录型，而（201315130，李明，男，计算机系，19，江苏南京市)则是该记录型的一个记录值。
​		**模式(schema) 是数据库中全体数据的逻辑结构和特征的描述，它仅仅涉及型的描述，不涉及具体的值**。模式的一个具体值称为模式的一个实例(instance)。同一个模式可以有很多实例。
​		**模式是相对稳定的，而实例是相对变动的**，因为数据库中的数据是在不断更新的。模式反映的是数据的结构及其联系，而实例反映的是数据库某一时刻的状态。
​		数据库管理系统在**体系结构上**通常都具有相同的特征，即**采用三级模式结构**（早期微机上的小型数据库系统除外）并**提供两级映像功能**。

#### 1.3.2 数据库系统的三级模式结构

​		数据库系统的三级模式结构是指数据库系统是由==外模式==、==模式==和==内模式==三级构成。如下图所示：

![image-20220212170255353](https://gitee.com/enchantedqaq/cloudimage/raw/master/img/image-20220212170255353.png)

​		**1. 模式（schema）**
​		**模式也称逻辑模式，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图**。它是数据库系统模式结构的中间层，既不涉及数据的物理存储细节和硬件环境，又与具体的应用程序、所使用的应用开发工具及高级程序设计语言无关。
​		模式实际上是数据库数据在逻辑级上的视图。一个数据库只有一个模式。数据库模式以某一种数据模型为基础，统一综合地考虑了所有用户的需求，并将这些需求有机地结合成一个逻辑整体。定义模式时不仅要定义数据的逻辑结构，例如数据记录由哪些数据项构成，数据项的名字、类型、取值范围等;而且要定义数据之间的联系，定义与数据有关的安全性、完整性要求。
​		数据库管理系统提供模式数据定义语言(模式 DDL）来严格地定义模式。











## 第2章	关系数据库

### 2.1 关系数据结构及形式化定义

​		按照数据模型的三个要素，**关系模型由关系数据结构**、**关系操作集合**和**关系完整性约束**三部分组成。下面将对这三部分内容进行分别介绍。其中2.1节讲解关系数据结构，包括关系的形式化定义及有关概念;2.2节讲解关系操作;2.3节讲解关系的三类完整性约束;2.4节讲解关系代数，这是关系数据库系统中实现关系操作的一种语言;最后，在2.5节介绍关系演算。

#### 2.1.1 关系

​		关系模型的数据结构非常简单，只包含单一的数据结构——关系。在用户看来，关系模型中数据的逻辑结构是一张扁平的二维表。

​		1.**域（domain）**
​		**定义 2.1**	==域是一组具有相同数据结构类型的值的集合==。
​		例如，自然数、整数、实数、长度小于25字节的字符串集合、{0，1}、{男，女}、大于等于0且小于等于100的正整数等,都可以是域。

​		2.**笛卡尔积（cartesian product）**
​		笛卡尔积是域上的一种集合运算。
​		**定义 2.2**	给定一组域 D~1~，D~2~，…，D~n~，允许其中某些域是相同的，D~1~，D~2~，…，D~n~的笛卡尔积为：
​		==D~1~×D~2~×…×D~n~ = { (d~1~，d~2~，…，d~n~) | d~i~∈D~i~，i=1, 2, …, n }==
​		其中，每一个元素(d~1~，d~2~，…，d~n~)叫作一个**n元组(n-tuple)**，或简称**元组（tuple)**。元素中的每一个值D~i~叫做一个**分量（component)**。
​		一个域允许的不同取值个数称为这个域的基数（cardinal number)。

![image-20220215161235607](https://gitee.com/enchantedqaq/cloudimage/raw/master/img/image-20220215161235607.png)

​		3.**关系（relation）**
​		**定义 2.3**	D~1~×D~2~×…×D~n~ 的子集叫做在域 D~1~，D~2~，…，D~n~ 上的关系，表示为：
$$
R(\ce{D1,D2,…,Dn})
$$
​		这里 R 表示关系的名字，n 是关系的 **目** 或 **度**  (degree)。
​		关系中的每个元素是关系中的元组，通常用 t 表示。
​		当 n=1 时，称该关系为 **单元** 关系 (unary relation)，或一元关系。
​		当 n=2 时，称该关系为 **二元** 关系 (binary relation)。
​		关系是笛卡儿积的有限子集，所以关系也是一张二维表，表的每行对应一个元组，表的每列对应一个域。由于域可以相同，为了加以区分，必须对每列起一个名字,称为属性 (attribute)。n目关系必有 n 个属性。

​		若关系中的 **某一属性组（1个或多个属性）的值能唯一地标识一个元组，而其子集不能**（若从该属性组中 **去掉任何一个属性**，该属性组就**不能唯一标识一个元组**），则称该属性组为候选码（candidate key).
​		***一个关系中，可能有很多组候选码***
​		当有多个候选码时，可以选定一个作为 **主码** (primary key)。
​		**DBMS** 以 **主码** 为主要线索管理关系中的各个元组。
​		包含在 **任何一个 候选码 中的属性** 被称作 **主属性** (prime attribute)，而其他属性被称作 **非主属性** (non-prime attribute) 或 **非码属性 ** (non-key attribute)。
​		最简单的，候选码只包含一个属性。
​		最极端的，所有属性构成这个关系的候选码，称为 **全码 (All-Key)**。

​		**关系可以有三种类型:基本关系（通常又称为基本表或基表)、查询表和视图表**。其中，基本表是实际存在的表，它是实际存储数据的逻辑表示；查询表是查询结果对应的表；视图表是由基本表或其他视图表导出的表,是虚表，不对应实际存储的数据。

#### 2.1.2 关系模式

​		在数据库中要区分型和值。关系数据库中，关系模式是型，关系是值。关系模式是对关系的描述,关系是元组的集合，因此关系模式必须指出这个元组集合的结构，即它由哪些属性构成，这些属性来自哪些域，以及属性与域之间的映像关系。

​		**定义 2.4**	关系的描述称为关系模式（relation schema)。它可以形式化地表示为：
$$
R(U,D,DOM,F)
$$
​		其中R为关系名，U为组成该关系的属性名集合，D为U中属性所来自的域，DOM为属性向域的映像集合，F为属性间数据的依赖关系集合。

#### 2.1.3 关系数据库

​		在关系模型中，实体以及实体间的联系都是用关系来表示的。例如导师实体、研究生实体、导师与研究生之间的一对多联系都可以分别用一个关系来表示。在一个给定的应用领域中，**所有关系的集合构成一个关系数据库**。
​		关系数据库也有型和值之分。**关系数据库的型也称为关系数据库模式，是对关系数据库的描述**。关系数据库模式包括若干域的定义，以及在这些域上定义的若干关系模式。
​		**关系数据库的值是这些关系模式在某一时刻对应的关系的集合，通常就称为关系数据库**。

#### 2.1.4 关系模型的存储结构

​		我们已经知道，**在关系数据模型中实体及实体间的联系都用表来表示，但表是关系数据的逻辑模型**。在关系数据库的物理组织中，有的关系数据库管理系统中一个表对应一个操作系统文件，将物理数据组织交给操作系统完成；有的关系数据库管理系统从操作系统那里申请若干个大的文件，自己划分文件空间，组织表、索引等存储结构，并进行存储管理。

### 2.2 关系操作

#### 2.2.1 基本的关系操作

​		关系模型中常用的关系操作包括查询（query）操作和插入（insert）、删除（delete）、修改（update）操作两大部分。
​		关系的查询表达能力很强，是关系操作中最主要的部分。查询操作又可以分为**选择（select）**、**投影（project）**、**连接（join）**、**除（divide）**、**并（union）**、**差（except）**、**交（intersection）**、**笛卡儿积 **等。其中**选择、投影、并、差、笛卡儿积是5种基本操作**，其他操作可以用基本操作来定义和导出，就像乘法可以用加法来定义和导出一样。
​		关系操作的特点是集合操作方式，即 **操作的对象和结果都是集合**。这种操作方式也称为一次一集合(set-at-a-time）的方式。相应地，非关系数据模型的数据操作方式则为一次一记录（record-at-a-time）的方式。

#### 2.2.2 关系数据语言的分类

![image-20220215191724792](https://gitee.com/enchantedqaq/cloudimage/raw/master/img/image-20220215191724792.png)

### 2.3 关系完整性

​		关系模型的完整性规则是对关系的某种约束条件。也就是说关系的值随着时间变化时应该满足一些约束条件。这些约束条件实际上是现实世界的要求。任何关系在任何时刻都要满足这些语义约束。
​		**关系模型中有三类完整性约束：实体完整性 (entity integrity)、参照完整性 (referentialintegrity) 和 用户定义的完整性 (user-defined integrity)**。其中**实体完整性和参照完整性是关系模型必须满足的完整性约束条件，被称作是关系的两个不变性**，应该由关系系统自动支持。用户定义的完整性是应用领域需要遵循的约束条件，体现了具体领域中的语义约束。

#### 2.3.1 实体完整性（对于主码而言）

​		**规则 2.1	实体完整性规则**	若属性（指一个或一组属性）A是基本关系R的主属性，则A不能取空值(null value)。所谓空值就是“不知道”或“不存在”或“无意义”的值。
​		对于实体完整性规则说明如下:
​		(1) 实体完整性规则是针对基本关系而言的。一个基本表通常对应现实世界的一个实体集。例如学生关系对应于学生的集合。
​		(2) 现实世界中的实体是可区分的，即它们具有某种唯一性标识。例如每个学生都是独立的个体，是不一样的。
​		(3) 相应地，关系模型中以主码作为唯一性标识。孙出啦祝掉法医
​		(4) 主码中的属性即主属性不能取空值。如果主属性取空值，就说明存在某个不可标识的实体，即存在不可区分的实体，这与第 (2) 点相矛盾，因此这个规则称为实体完整性。

#### 2.3.2 参照完整性（对于外码而言）

​		**定义 2.5**	设 F 是基本关系 R 的一个或一组属性，但不是关系 R 的码，K~s~ 是基本关系 S 的主码。如果 F 与 K~s~ 相对应，则称 F 是 R 的 **外码 (foreign key)**，并称基本关系 R 为参照关系 (referencing relation)，基本关系 S 为被参照关系 (referenced relation) 或目标关系 (target relation)。关系 R 和 S 不一定是不同的关系。

![image-20220215192703473](https://gitee.com/enchantedqaq/cloudimage/raw/master/img/image-20220215192703473.png)

​		显然，目标关系 S 的主码 K~s~ 和参照关系 R 的外码 F 必须定义在同一个（或同一组）域上。

​		***两个关系通常是靠外码连接起来的***

​		**规则 2.2**	**参照完整性规则**	若属性 (或属性组) F 是基本关系 R 的外码，它与基本关系 S 的主码 K，相对应（基本关系 R 和 S 不一定是不同的关系），则对于 R 中每个元组在 F 上的值必须:

- 要么取空值 ( F 的每个属性值均为空值 )；
- 要么等于 S 中某个元组的主码值。

#### 2.3.3 用户自定义完整性

​		用户针对具体的应用环境定义的完整性约束条件。
​		例如：uid要求是10位数字的正整数、username不能为空等。

### 2.4 关系代数

​		关系代数是一种抽象的查询语言，它**用对关系的运算来表达查询**。

​		关系代数的运算按运算符的不同可分为 **传统的集合运算** 和 **专门的关系运算** 两类。其中,传统的集合运算将关系看成元组的集合,其运算是从关系的“水平”方向，即行的角度来进行;而专门的关系运算不仅涉及行，而且涉及列。比较运算符和逻辑运算符是用来辅助专门的关系运算符进行操作的。

![image-20220215193622630](https://gitee.com/enchantedqaq/cloudimage/raw/master/img/image-20220215193622630.png)

#### 2.4.1 传统的集合运算

​		传统的集合运算是二目运算，包括 **并**、**差**、**交**、**笛卡儿积** 4种运算。

| **UNION（并）**                   | **R** | **S** | **R∪S** |
| :-------------------------------- | :---: | :---: | :-----: |
| **INTERSECTION（交）**            | **R** | **S** | **R∩S** |
| **DIFFERENCE（差）**              | **R** | **S** | **R-S** |
| **Cartesian PRODUCT（笛卡尔积）** | **R** | **S** | **R×S** |

​		传统集合运算举例：

![image-20220215194036206](https://gitee.com/enchantedqaq/cloudimage/raw/master/img/image-20220215194036206.png)

#### 2.4.2 专门的关系运算

​		专门的关系运算包括 **选择**、**投影**、**连接**、**除** 运算等。

| PROJECT（投影）    |   R   |       |    π~A~(R)    |
| :----------------- | :---: | :---: | :-----------: |
| **SELECT（选择）** | **R** |       | **σ~Con~(R)** |
| **JOIN（连接）**   | **R** | **S** | **R⋈~AθB~S**  |
| **DIVISION（除）** | **R** | **S** |    **R÷S**    |

​		设有一个学生—课程数据库，包括学生关系 Student 、课程关系 Course 和选修关系 SC 如下图所示。下面的多个例子将对这三个关系进行运算。

![image-20220215194650875](https://gitee.com/enchantedqaq/cloudimage/raw/master/img/image-20220215194650875.png)

![image-20220215194810569](https://gitee.com/enchantedqaq/cloudimage/raw/master/img/image-20220215194810569.png)

​		**1.选择（selection）**
​		选择又称为限制（restriction)。它是在关系 R 中选择满足给定条件的诸元组，记作：
​				***σ~F~(R)={t|t∈R∧F(t)='真'}***
​		其中 F 表示选择条件，它是一个逻辑表达式，取逻辑值 “真” 或 “假”。
​		逻辑表达式F的基本形式为：
​				***X~1~θY~1~***
​		其中 θ 表示比较运算符，它可以是>，≥，<，≤，=或<>（不等号）。X~1~，Y~1~等是属性名，或为常量，或为简单函数;属性名也可以用它的序号来代替。在基本的选择条件上可以进一步进行逻辑运算，即进行求非(┐)、与（⋀）、或（⋁）运算。
​		选择运算实际上是从关系 R 中选取使逻辑表达式 F 为真的元组。这是 **从行的角度进行的运算**。

​		**[例2.1]**	查询信息系（IS 系）全体学生。

​				**σ~Sdept='IS'~(Student)**

​		结果如下表所示：

|    Sno    | Sname | Ssex | Sage | Sdept |
| :-------: | :---: | :--: | :--: | :---: |
| 201215125 | 张立  |  男  |  19  |  IS   |

​		**2.投影（projection）**
​		关系R上的投影是从R中选择出若干属性列组成新的关系。记作：
​				***π~A~(R) = {t[A] | t∈R}***
其中A为R中的属性列。
​		投影操作是 **从列的角度进行的运算**。

​		**[例2.2]**	查询学生的姓名和所在系，即求Student关系上学生姓名和所在系两个属性上的投影。

​				**π~Sname，Sdept~(Student)**

​		结果如下表所示：

| Sname | Sdept |
| :---: | :---: |
| 李勇  |  CS   |
| 刘晨  |  CS   |
| 王敏  |  MA   |
| 张立  |  IS   |

​		**[例2.3]**	查询学生关系Student中都有哪些系，即查询关系 Student 上所在系属性上的投影。

​				**π~Sdept~(Student)**

​		结果如下图所示：

![image-20220216174800855](https://gitee.com/enchantedqaq/cloudimage/raw/master/img/image-20220216174800855.png)

​		投影之后**不仅取消了原关系中的某些列，而且还可能取消某些元组**，因为取消了某些属性列后，就可能出现重复行，应取消这些完全相同的行。

​		**3.连接（join）**
​		连接也称为 θ 连接。它是从两个关系的笛卡儿积中选取属性间满足一定条件的元组。记作：

![image-20220218131012392](https://gitee.com/enchantedqaq/cloudimage/raw/master/img/image-20220218131012392.png)

​		其中，A 和 B 分别为R 和 S 上列数相等且可比的属性组，θ 是比较运算符。连接运算从 R 和 S的笛卡儿积 R×S 中选取 R 关系在 A 属性组上的值与 S 关系在 B 属性组上的值满足比较关系 θ 的元组。
​		连接运算中有两种最为重要也最为常用的连接，**一种是等值连接（equijoin)**，**另一种是自然连接(natural join)**。
​		**θ 为 “=” 的连接运算称为等值连接**。它是从关系R与S的广义笛卡儿积中选取A、B属性值相等的那些元组,即等值连接为：

![image-20220218131322833](https://gitee.com/enchantedqaq/cloudimage/raw/master/img/image-20220218131322833.png)

​		**自然连接是一种特殊的等值连接**。它要求两个关系中进行比较的分量必须是同名的属性组,并且在结果中把重复的属性列去掉。即若R和S中具有相同的属性组B,U为R和S的全体属性集合，则自然连接可记作：

![image-20220218131348375](https://gitee.com/enchantedqaq/cloudimage/raw/master/img/image-20220218131348375.png)

![image-20220218132057395](https://gitee.com/enchantedqaq/cloudimage/raw/master/img/image-20220218132057395.png)

​		两个关系 R 和 S 在做自然连接时，选择两个关系在公共属性上值相等的元组构成新的关系。此时，关系 R中某些元组有可能在 S 中不存在公共属性上值相等的元组，从而造成 R 中这些元组在操作时被舍弃了，同样, S 中某些元组也可能被舍弃。**这些被舍弃的元组称为悬浮元组 (dangling tuple)**。例如，在图2.7(e)的自然连接中，R 中的第4个元组，S 中的第5个元组都是被舍弃掉的悬浮元组。
​		如果**把悬浮元组也保存在结果关系中，而在其他属性上填空值(NULL),那么这种连接就叫做外连接 (outer join)，记作 R⋈S**；如果**只保留左边关系 R 中的悬浮元组就叫做左外连接 (left outer join或left join)，记作R⋊S**；如果**只保留右边关系 S 中的悬浮元组就叫做右外连接（right outer join或right join)，记作R⋉S**。图(a)是图2.7中的关系 R 和关系 S 的外连接，图(b)是左外连接，图(c)是右外连接。

![image-20220218132814322](https://gitee.com/enchantedqaq/cloudimage/raw/master/img/image-20220218132814322.png)

​		**4.除运算（division）**
​		设关系R 除以关系S 的结果为关系 T，则 **T 包含所有在 R 但不在 S 中的属性及其值，且 T 的元组与 S 的元组的所有组合都在 R 中**。
​		下面用象集来定义除法:
​		给定关系 R(X，Y) 和 S(Y，Z)，其中 X、Y、Z 为属性组。R 中的 Y 与 S 中的 Y 可以有不同的属性名,但必须出自相同的域集。
​		R 与 S 的除运算得到一个新的关系 P(X)，P 是 R 中满足下列条件的元组在 X 属性列上的投影：元组在 X 上分量值 x 的象集 Y~x~ 包含 S 在 Y 上投影的集合。记作：
​				***R÷S = {t~r~ [X] | t~r~∈ R⋀ ∏~Y~(S)⊆Y~x~ }***
其中 Y 为 x 在 R 中的象集,x=t~r~ [X]。
​		除操作是 **同时从行和列角度进行运算**。
​		**[例2.4]**	设关系 R、S 分别如下图，则 R÷S 的结果为：

![image-20220218134315557](https://gitee.com/enchantedqaq/cloudimage/raw/master/img/image-20220218134315557.png)

​		在关系 R 中，A 可以取4个值{a~1~，a~2~，a~3~，a~4~}。其中：
​				a~1~的象集为{(b~1~，c~2~)，(b~2~，c~3~)，(b~2~，c~1~)}
​				a~2~的象集为{(b~3~，c~7~)，(b~2~，c~3~)}
​				a~3~的象集为{(b~4~，c~6~)}
​				a~4~的象集为{(b~6~，c~6~)}
S 在(B，C)上的投影为{(b~1~，c~2~)，(b~2~，c~1~)，(b~2~，c~3~)}。
​	显然只有显然**只有a~1~的象集(B，C)~a1~包含了 S 在(B，C)属性组上的投影**，所以
​			**R÷S = {a~1~}**

## 第 3 章	关系数据库标准语言 SQL

​		结构化查询语言（Structured Query Language，SQL）是关系数据库的标准语言，也是一个通用的、功能极强的关系数据库语言。其功能不仅仅是查询，而是包括数据库模式创建、数据库数据的插入与修改、数据库安全性完整性定义与控制等一系列功能。

### 3.1 学生—课程数据库

​		本章以学生—课程数据库为例来讲解 SQL 的数据定义、数据操纵、数据查询和数据控制语句。
​		为此，首先要定义一个学生—课程模式 S-T。学生—课程数据库中包括以下三个表，它们的定义如下：

- 学生表：Student(Sno,Sname,Ssex,Sage,Sdept)
- 课程表：Course(Cno,Cname,Cpno,Ccredit)
- 学生选课表：SC(Sno,Cno,Grade)

**Student表：**

| 学号 Sno  | 姓名 Sname | 性别 Ssex | 年龄 Sage | 所在系 Sdept |
| :-------: | :--------: | :-------: | :-------: | :----------: |
| 201215121 |    李勇    |    男     |    20     |      CS      |
| 201215122 |    刘晨    |    女     |    19     |      CS      |
| 201215123 |    王敏    |    女     |    18     |      MA      |
| 201215125 |    张立    |    男     |    19     |      IS      |

**Course表：**

| 课程号 Cno | 课程名 Cname | 先行课 Cpno | 学分 Ccredit |
| :--------: | :----------: | :---------: | :----------: |
|     1      |    数据库    |      5      |      4       |
|     2      |     数学     |             |      2       |
|     3      |   信息系统   |      1      |      4       |
|     4      |   操作系统   |      6      |      3       |
|     5      |   数据结构   |      7      |      4       |
|     6      |   数据处理   |             |      2       |
|     7      |  PASCAL语言  |      6      |      4       |

**SC表（学生—课程关联表）：**

| 学号 Sno  | 课程号 Cno | 成绩 Grade |
| :-------: | :--------: | :--------: |
| 201215121 |     1      |     92     |
| 201215121 |     2      |     85     |
| 201215121 |     3      |     88     |
| 201215122 |     2      |     90     |
| 201215122 |     3      |     80     |

### 3.2 数据定义

​		关系数据库系统支持三级模式结构，其模式、外模式和内模式中的基本对象有模式、表、视图和索引等。因此SOL 的数据定义功能包括模式定义、表定义、视图和索引的定义。

![image-20220220193411454](https://gitee.com/enchantedqaq/cloudimage/raw/master/img/image-20220220193411454.png)

#### 3.2.1 模式的定义与删除

​		**1.定义模式**
​		在SOL 中，模式定义语句如下:
​				***CREATE SCHEMA <模式名> AUTHORIZATION <用户名>;***
如果没有指定<模式名>，那么<模式名>隐含为<用户名>。
​		要创建模式，调用该命令的用户必须拥有数据库管理员权限，或者获得了数据库管理员授予的 CREATE SCHEMA 的权限。
​		**[例 3.1]**	为用户 WANG 定义一个学生—课程模式 S-T。

​				**CREATE SCHEMA "S-T" AUTHORIZATION WANG**;

​		**[例 3.2]**	**CREATE SCHEMA AUTHORIZATION WANG**；

​		该语句没有指定<模式名>，所以<模式名>隐含为用户名 WANG。

​		目前，在 CREATE SCHEMA 中可以接受 CREATE TABLE, CREATE VIEW和 GRANT子句。也就是说用户可以在创建模式的同时在这个模式定义中进一步创建基本表、视图，定义授权。即
​				***CREATE SCHEMA <模式名> AUTHORIZATION <用户名> [<表定义字句> |<视图定义子句>| <授权定义子句>] ;***
​		**[例 3.3]**	为用户 ZHANG 创建一个模式 TEST，并且在其中定义一个表 TAB1。

​				CREATE SCHEMA TEST AUTHORIZATION ZHANG
​				CREATE TABLE TAB1(COL1 SMALLINT,
​													 COL2 INT,
​													 COL3 CHAR(20),
​													 COL4 NUMERIC(10,3),
​													 COL5 DECIMAL(5,2)
​													 );

​		**2.删除模式**
​		在 SQL 中，删除模式语句如下：
​		***DROP SCHEMA <模式名><CASCADE |RESTRICT***;
其中 CASCADE 和 RESTRICT 两者必选其一。选择了 CASCADE（级联），表示在删除模式的同时把该模式中所有的数据库对象全部删除;选择了 RESTRICT（限制），表示如果该模式中已经定义了下属的数据库对象（如表、视图等)，则拒绝该删除语句的执行。只有当该模式中没有任何下属的对象时才能执行 DROP SCHEMA 语句。

​		**[例 3.4]**	**DROP SCHEMA ZHANG CASCADE**;

​		该语句删除了模式 ZHANG，同时，该模式中已经定义的表 TAB1 也被删除了。

#### 3.2.2 基本表的定义、删除和修改

​		**1.定义基本表**
​		创建了一个模式就建立了一个数据库的命名空间，一个框架。在这个空间中首先要定义的是该模式包含的数据库基本表。
​		SQL 语言使用 **CREATE TABLE** 语句定义基本表，其基本格式如下：
**​				CREATE TABLE <表名> (<列名><数据类型> [列级完整性约束条件],**
**​														  <列名><数据类型> [列级完整性约束条件],**
**​														  …**
**​														  <列名><数据类型> [列级完整性约束条件],**
**​														  <表级完整性约束条件>);**
​		建表的同时通常还可以定义与该表有关的完整性约束条件，这些完整性约束条件被存入系统的数据字典中，当用户操作表中数据时由关系数据库管理系统自动检查该操作是否违背这些完整性约束条件。如果完整性约束条件涉及该表的多个属性列，则必须定义在表级上，否则既可以定义在列级也可以定义在表级。

​		**[例 3.5]**	建立一个 “学生” 表 Student。

​				**CREATE TABLE Student**
**​					(Sno CHAR(9) PRIMARY KEY,**
**​					Sname CHAR(20) UNIQUE,**
**​					Ssex CHAR(2),**
**​					Sage SMALLINT,**
**​					Sdept CHAR(20)**
**​					);**

​		系统执行该 CREATE TABLE 语句后,就在数据库中建立一个新的空 “学生” 表 Student，并将有关 “学生” 表的定义及有关约束条件存放在数据字典中。

​		**[例 3.6]**	建立一个 “课程” 表 Course。

​				**CREATE TABLE Course**
**​					(Cno CHAR(4) PRIMARY KEY,	/* 列级完整性约束条件，Cno 是主码 * /**
**​					Cname CHAR(40) NOT NULL,	 /* 列级完整性约束条件，Cname 不能取空值 * /**
**​					Cpno CHAR(4),	/* Cpno 的含义是先修课 * /**
**​					Cceredit SMALLINT,**
**​					FOREIGN KEY (Cpno) REFERENCES Course(Cno)	/* 表级完整性约束条件，Cpno 是外码，被参考表是 Course，被参照列是 Cno */**
**​					);**

​		本例说明 **参照表和被参照表可以是同一个表**。

​		**[例 3.7]**	建立一个 “学生选课” 表 SC。

​				**CREATE TABLE SC**
**​					(Sno CHAR(9),**
**​					Cno CHAR(4),**
**​					Grade SMALLINT),**
**​					PRIMARY KEY (Sno,Cno),**
**​					FOREIGN KEY (Sno) REFERENCES Student(Sno),**
**​					FOREIGN KEY (Cno) REFERENCES Course(Cno)**
**​					);**

​		**2.数据类型**
​		关系模型中一个很重要的概念是域。每一个属性来自一个域，它的取值必须是域中的值。
​		在 SQL中域的概念用数据类型来实现。定义表的各个属性时需要指明其数据类型及长度。SQL 标准支持多种数据类型，下面列出了几种常用数据类型。要注意，不同的关系数据库管理系统中支持的数据类型不完全相同。









































































1.什么是模式(Schema)

​		对数据库中数据所进行的一种结构性的描述，所观察到数据的结构信息.

![image-20220207152122733](C:\Users\EnchantedQAQ\AppData\Roaming\Typora\typora-user-images\image-20220207152122733.png)

------

2.什么是视图(View）

​		某一种表现形式下表现出来的数据库中的数据

***模式(Schema)是对视图(View)的一个抽象***

***视图(View)是一种模式(Schema)下的展示的一组数据(对模式的具体)***

------

3.第一范式

​		属性不可再分

![image-20220209140308816](C:\Users\EnchantedQAQ\AppData\Roaming\Typora\typora-user-images\image-20220209140308816.png)



![image-20220209144009332](C:\Users\EnchantedQAQ\AppData\Roaming\Typora\typora-user-images\image-20220209144009332.png)

#### 
